# 병합정렬

합병정렬은 항상 nlogn 의 성능을 내는 알고리즘으로 힙정렬과 같고 최악상황의 퀵(n^2) 보다 안정적이다.

하지만 평균적으로 퀵정렬보다 느린 성능을 보이며 알고리즘 구현에있어 힙정렬보다 메모리를 더 많이먹는다.

합병(병합)정렬은 **분할정복**알고리즘이다. 

> 분할정복은 하나의 문제를 잘개 쪼개어(분할하여) 문제를 해결하는 방법

합병정렬이 대표적인 분할정복을 사용하는 알고리즘인데. 정렬할 배열을 하나의 원소로 쪼개어 비교하며 정렬하는 방법이다.

**이 정렬은 두가지 순서만 알면 되는데.** 

**1.분할 (가장 작은 단위까지 분할)**

**2.정렬 (가장 작은 단위부터 정렬)**

과정을 정렬이 완료될때까지 반복한다.



**코드 예시**

> n개의 길이를 가진 배열의 값을 받고, 병합정렬

```c++
//병합정렬 알고리즘, 작은 수 부터 오름차순으로 정렬
#include<iostream>
#include<vector>

using namespace std;

unique_ptr<int[]> arr1;  // arr2 라는 스마트 포인터(배열) 생성 //받은 값을 저장할 배열
unique_ptr<int[]> arr2;  // arr2 라는 스마트 포인터(배열) 생성 //임시로 사용할 배열


void merge(int left, int right)
{
	int mid = (left + right) / 2;

	int i = left;
	int j = mid + 1;  
	int k = left; // 임시 배열 arr2 에 사용할 변수

	while (i <= mid && j <= right) {  
	// i는 왼쪽부터, j는 중간 + 1부터 진행
	// i가 mid를 넘어가거나, j가 right를 넘어가는 순간 while문 종료
		if (arr1[i] <= arr1[j]) {  // arr1배열에서 두 값 비교
			// arr[i]에 들어있는 값이 arr1[j]에 들어있는 값보다 작으면 
			arr2[k++] = arr1[i++]; // arr2[k]에 arr1[i]의 값을 할당 후 k, i에 각각 ++
		}
		else {
			arr2[k++] = arr1[j++];
		}
	}

	// 위의 while문에서 i가 mid를 넘어버리면, j는 right에 다다르지 못하고 반복문이 끝나기 때문에
	// 남은 데이터를 arr2에 넣어준다
	if (i > mid) {  
		for (int t = j; t <= right; t++)
		{
			arr2[k++] = arr1[t];
		}
	}
	else
	{
		for (int t = i; t <= mid; t++)
		{
			arr2[k++] = arr1[t];
		}
	}

	//임시 저장용 배열 arr2에서 원래 배열인 arr1로 값을 넣어준다. 
	for (int t = left; t <= right; t++) {
		arr1[t] = arr2[t];
	}

}

void partition(int left, int right) {  //인자는 맨 왼쪽, 맨 오른쪽을 의미함

	int mid;
	if (left < right) { // left, right 가 같으면
		mid = (left + right) / 2;  //중간지점 잡아놓고, 
		partition(left, mid);  // 맨 왼쪽부터 중간까지 
		partition(mid+1,right );  //중간부터 맨 오른쪽까지
		// 재귀

		merge(left, right);
		
	}

	// 계속 쪼개지다 보면,  mid가 인자로 들어갈 때 left또는 right와 같아질 땐 함수 호출해도 동작없음
}

int main(void)
{
	int n;
	cin >> n;

	arr1 = make_unique<int[]>(n);  // 힙에(스마트 포인터를 사용해서) 배열 생성
	arr2 = make_unique<int[]>(n);  

	for (int i = 0; i < n; i++) {
		cin >> arr1[i];
	}

	partition(0, n - 1); // 배열의 시작 index 숫자, 배열의 끝 index숫자 

	for (int i = 0; i < n; i++) {
		cout << arr1[i] << endl;
	}

	return 0;
}
```

