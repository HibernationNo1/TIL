# new와 delete 사용(동적 메모리)

메모리는 `스택`, `힙`두 가지가 있으며 일반적인 변수 선언은 스택에,  new 키워드를 사용하면 operator new를 호출되어 heap에 메모리가 할당된다. 

heap에서 변수에 사용할 공간은 new 키워드로 생성한다. 다 사용한 후 프로그램의 다른 영역에서 재사용하도록 이 공간을 해제하려면 delete 키워드를 사용한다.

## 메모리의 작동 과정 및 형태

#### **1. 기본형** >> `타입 포인터변수명 = new 타입(값);`	`변수명 = new 타입;`

```c++
int ptr = nullptr;  // ptr변수 스택에 할당
prt = new int;		// ptr변수는 포인터 변수가 됨. 
// ptr은 여전히 스택에 있지만, 변수가 가리키는 값`*ptr`은 힙에 있다.

delete ptr; 		// 메모리 해제
ptr = nullptr;
// 메모리를 해제한 포인터는 nullptr로 초기화. 

// 위 코드의 원 라이너 형태
int* num = new num(10);   	// 10으로 num을 초기화
cout << *num <<endl;     	// 10 출력

num = &a;   
cout << *num << endl;   	// a 값 출력

delete num;					
num = nullptr;  
```

> - 변수에 필요한 메모리 블록을 할당하려면 new에 그 변수의 타입을 지정해서 호출한다.    `prt = new int;` , `int* num = new num(10);` 그럼 할당된 메모리에 대한 포인터가 리턴된다.
>
> - 힙 메모리를 해제하려면 delete 키워드에 해제할 메모리를 가리키는 포인터를 지정한다.  `delete ptr;`
>
> - new를 사용해서 할당된 배열은 동적으로 할당된 배열일 뿐 동적 배열이 아니다.
>
> - 포인터 역시 일종의 변수이기 때문에 스택이나 힙에 존재한다. 반면, 동적 메모리는 항상 힙에 할당된다.
>
>   > 위 코드에서 포인터 변수: `ptr`, `num`
>
> - new의 리턴값을 무시하거나 그 포인터를 담았던 변수가 스코프를 벗어나면 할당했던 메모리에 접근할 수 없다.  **메모리 누수(메모리 릭)**
>
>   >  ex) 변수 없이 선언:  `new int;`     
>
> - 항상 포인터 변수를 선언하자마자 nullptr나 적절한 포인터로 초기화해야 한다. 
>
>   > 초기화를 하지 않으면 쓰레기값이 들어가게 되고, 나중에 실수로 사용해버리면 예측할 수 없는 동작이 발생해서 메모리를 손상시킬 수 있다.
>
> 
>
> **포인터가 스택과 힙에 모두 있을 때**

```c++
int** ptr = nullptr; // ptr은 스택에 할당. 포인터 변수임.
ptr = new int*;		 //  new 키워드로 인해 ptr변수가 가리키는 값`*ptr`은 힙에 있다.
*prt = new int;		 // 힙에 있는 `*ptr`변수가 가리키는 값`**ptr` 또한 new 키워드로 인해 힙에 있다.

delete *ptr;
delete ptr;
```

> > 스택: `ptr`			힙: `*ptr`, `**ptr`



#### **2. 배열**

> 배열은 서로 타입이 같은 원소들을 변수 하나에 담아서 각 원소를 인덱스로 접근하게 해준다.
>
> 배열을 heap에 할당하면 실행 시간에 크기를 정할 수 있다는 장점이 있다.

```c++
int* arr = new int[5];     
// heap에 int 값 다섯 개를 담는 배열에 메모리를 할당해서 그 공간을 가리키는 포인터를 arr변수에 저장한다.
arr[2] = 22;  	 // arr배열의 index 2에 해당하는 지점에 값을 할당
*(arr+3) = 33; 	 // 포인터 연산자 사용. arr[3] =33; 과 같다.

delete [] arr;   // arr을 호출한 횟수만큼 delete를 호출해서 메모리를 해체한다.
arr = nullptr;
```

> - 1차원 배열은 new키워드로 인해 heap에 연속적인 공간에 할당된다.
> - `arr`변수는 배열의 0번째 원소를 가리킨다.
>
> - 배열 버전의 delete인 delete[]를 사용하지 않으면 메모리 누수 또는 손상이 발생할 수 있다.
>
> 
>
> **다차원 배열**  ex) 2차원
>
> 다차원 배열은 메모리에서 일차원 배열처럼 표현되며 배열의 크기와 이를 접근하는 방식만 다르다.
>
> 하지만 heap에서는 배열이 아니면 연속적으로 할당되지 않기 때문에 2차원 이상의 배열부터는 메모리 할당 방식이 다르다.
>
> 예시 배열: `int arr[n][m]`

 ```c++
 int** arr =new int*[n];     // 첫 번째 차원의 배열을 할당
 for (int i =0; i<n; i++)	 // 2차원 배열은 하나씩 할당
 {
     arr[i] = new int[m];    // 두 번째 차원의 배열 중 i번째 배열 할당 
 }

arr = &arr2;     		 	 // 다른 배열로 입력도 가능 (arr길이가 arr2보다 크거나 같아야함 )
 ```
>
> - 가장 상위 인덱스에 해당하는 차원의 배열`arr[n]`을 연속적인 공간에 먼저 할당한다. 그런 다음 이 배열의 각 원소에 '두 번째 인덱스에 해당하는 차원의 배열`arr[][m]`을 가리키는 포인터'를 저장한다.
> - 하위 배열(2차원 이상 배열)을 할당하는 작업은 일차원 힙 배열을 할당하듯이 직접 하나씩 할당해야 한다.
> - 2 배열은 각각의 배열 자체만 메모리가 연속적으로 할당되지만, 모든 2차원 배열이 함께 연속적으로 할당되지는 않는다. (배열의 가지형대)
>- 다차원 힙 배열에 할당된 메모리를 해제할 때도 마찬가지로 delete[]로 하위 배열을 해제할 수 없기 때문에 일일이 해제해야 한다.
> 
 ```c++
for (int i = 0; i < n; i++)
{
   delete [] arr[i]; //  두 번째 차원의 배열을 해제
}
 delete [] arr;   // 첫 번째 차원의 배열을 해제
 arr = nullptr;
 ```
> > 



#### **3. 객체 기본형**

>`new`는 단순히 메모리를 할당하는데 그치지 않고 객체까지 만들 수 있다.

```c++
Foo* myFoo = new Foo();		// Foo라는 클래스의 객체 myFOO를 동적 할당
myFoo -> go();    // Foo클래스의 멤버함수 go(); 실행
// 포인터로 객체를 선언하면 myFoo.go(); 가 아닌 myFoo -> go(); 형태로 메서드 실행 
delete myFoo;
```

> - `Foo* myFoo = new Foo();`이 문장은 두 가지 일을 한다.
>
> 먼저 operator new를 호출해서 Foo 객체를 저장하는 데 충분한 크기의 힙 영역(메모리)을 할당한다. 그리고 Foo의 생성자를 호출해서 객체를 생성한다. 생성자의 실행이 끝나야 myFoo에 대한 포인터가 리턴된다. (포인터를 myFoo에 저장)
>
> Foo의 데이터 멤버와 메서드는 이 포인터로 접근할 수 있다.
>
> - `delete myFoo;`  이 문장은
>
> 먼저 myFoo의 소멸자를 호출한 다음 operator delete를 호출해서 myFoo에 할당된 메모리를 해제한다.
>
> 
>
> > 추가 내용
>
> **배치 new 연산자**
>
> 실제로 객체를 할당하지 않고 기존에 저장된 객체의 생성자를 호출만 하는 특수한 형태의 new 표현식이다.
>
> 이 연산자를 이용하면 기존에 확보된 메모리에서 객체를 생성할 수 있다.
>
> ```c++
> viod* myFoo = Foo();
> exmple* cell = new(myFoo) exmple();  //exmple class
> ```
>
> - 이런 기능은 매번 메모리를 해제하지 않고 재사용할 수 있도록 메모리 풀을 구현할때 유용하다.



#### **4. 객체 배열**

> N개의 객체로 구성된 배열을 new[N]으로 할당하면 객체를 담기에 충분한 크기의 N개의 블록이 heap의 연속된 공간에 할당된다.

```c++
Foo* tmp()			// Foo라는 클래스
{
    Foo* arr = new Foo[4];   //4의 크기를 가진 Foo 객체 배열 arr 생성
    return arr;
    
    delete arr;			// 함수 안에서 new를 했으니 delete도 함수 한에서
}
```

> - new[]를 호출하면 각 객체마다 디폴트 생성자(영인수 생성자)가 호출된다. 
>
>   > new[]로 객체 배열을 할당하면 형식에 맞게 초기화된 객체 배열을 가리키는 포인터가 리턴된다.
>
> - 네 개의 Foo 객체로 구성된 배열을 할당하면 Foo클래스의 생성자가 네 번 호출된다.
>
> - new[]를 호출한 만큼 delete[]도 호출해야 하기 때문에 tmp()를 호출한 측에서 배열을 다 쓰고 나면 `delete [] arr;` 을 해야한다.
>
> - 여기서  arr는 동적으로 할당된 배열이다. (!= 동적 배열)

```c++
Foo* arr = new Foo[4]

delete [] arr;
arr = nullptr;
```

> >  스택:  `arr`(포인터 변수)  				힙: `arr[0]`, `arr[1]`, `arr[2]`, `arr[3]` 
>
> 
>
> **배열의 원소가 객체일 때**

```c++
Foo** arr = new Foo[4]
for(int i =0; i<4, i++) {arr[i] = new Foo();}
// 각 포인터 마다 객체를 동적 할당
```

> >  스택: `arr`(포인터 변수)
> >
> >  힙: `*arr_1[0]`, `*arr_1[1]`, `*arr_1[2]`, `*arr_1[3]`, `**arr_1[0]`,  `**arr_1[1]`, `**arr_1[2]`, `**arr_1[3]`   
>
> - 배열의 원소가 객체일 때만 모든 원소에 대해 소멸자가 호출된다. 
> - 포인터 배열에 대해 delete[]를 호출할 때는 각 원소가 가리키는 객체를 일일이 해제해야 한다.

```c++
for(int i =0; i<4, i++) {delete arr_1[i];}
// 각 포인터 마다 할당된 객체 삭제

delete [] arr_1;
arr_1 = nullptr;
```

>
>
>참고 내용
>
>[class에 관하여](https://github.com/HibernationNo1/TIL/blob/master/study_C%2B%2B/class%EC%97%90%20%EA%B4%80%ED%95%98%EC%97%AC.md)

