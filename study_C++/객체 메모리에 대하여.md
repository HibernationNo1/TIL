# 객체 메모리

객체 메모리 규칙

1. 객체 메모리에서 멤버값은 자신의 사이즈의 배수의 위치에서 시작해야 한다.

```c++
class Foo
{
    private:
    int a;  // 0에서 4바이트까지 공간을 차지
    int b;	// 4에서 8바이트까지 공간을 차지
    double c; 		// 8에서 16바이트까지의 공간을 차지
};  
```

>  Foo의 객체는 4+4+8 = 16바이트의 크기를 차지한다.

2. 객체의 전체 사이즈는 멤버값 중 가장 큰 사이즈의 배수가 되어야 한다.

> 위에서 double의 위치를 바꾸면

```c++
class Foo
{
    private:
    int a;  // 0에서 4바이트까지 공간을 차지
    double c; 	// 8에서 16바이트까지의 공간을 차지
    // 4 ~ 8바이트 사이는 공간이 비어버리기 때문에 패딩을 넣어주게 된다.
    int b;	// 16에서 20바이트까지 공간을 차지
};  
```

> Foo의 객체는 8바이트의 배수가 되어야 하기 때문에 24바이트의 크기가 되고, 20 ~ 24바이트 공간에는 패딩이 강제적으로 들어가게 된다.
>
> 패딩: 



CPU는 멀티코어 시스템으로 동작하고 있으며, 데이터 엑세스 타임을 최소화 하기 위해서 Cache라는 시스템을 가지고 있다.

Cache의 가장 작은 기본 단위를 cachline이라고 하며, cachline는 일반적으로 64바이트를 가지고 있다. 각각 코어마다 이 cachline을 가지고 있으며, 각각의 코어가 같은 공간에 접근하게 되면 false Sharing(거짓 공유)이 발생한다.

false Sharing: cachline에 의한 하드웨어적 구조 때문에 데이터를 64바이트로 자르게 되고, 그 과정에서 몸이 잘려진 데이터가 발생한다면, 잘려진 몸은 각각 다른 코어로 들어가는 상황.

```c++
class alignas(32) Foo   
{
    private:
    int a;  
    double c; 	
   
    int b;	
}; 
```

> alignas(32): 32바이트마다,  다 못 채운 데이터 공간에 패딩을 넣어줌으로서  객체 사이즈를 32바이트로 만들어준다.
>
> 이러한 기능으로 객체 크기를 cachline에 의해 잘리지 않도록 맞춰 준다면 false Sharing이 발생하지 않는다.

