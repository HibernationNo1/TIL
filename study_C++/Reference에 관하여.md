# Reference

레퍼런스란 일종의 변수에 대한 별칭으로 레퍼런스를 이용해서 수정한 내용은 그 레퍼런스가 가리키는 변수의 값에 그대로 반영된다.

래퍼런스는 변수의 주소를 가져오거나 변수에 대한 역참조 연산을 수행하는 작업을 자동으로 처리해주는 특수한 포인터다.



## 1. 레퍼런스 변수

레퍼런스 변수는 반드시 생성하자마자 초기화해야 한다. 

레퍼런스는 처음 초기화할 때 지정한 변수만 가리킨다. 

레퍼런스는 한 번 생성되고 나면 가리키는 대상을 바꿀 수 없다.

### - 레퍼런스 변수 선언

```c++
int x = 3;      // 변수 선언
int& foo = x;	// 레퍼런스 변수 foo 생성, 레퍼런스에 x를 대입해서 바로 초기화
// 이제 Ref를 사용하는 것은 x를 사용하는것과 같다.
foo = 10;
// Ref에 어떤 값을 대입하면 x의 값도 바뀐다.
```

> - 레퍼런스를 초기화하고 나면 레퍼런스가 가리키는 변수를 변경할 수 없고, 그 변수의 값만 바꿀 수 있다.
>
> - 한 번 선언된 레퍼런스에 다른 변수를 대입하면 레퍼런스가 가리키는 대상이 바뀌는 것이 아니라 레퍼런스가 원래 가리키더 변수의 값이 새로 대입한 변수의 값으로 바뀌게 된다.
>
> - 정수 리터럴처럼 이름 없는 값에 대해서는 레퍼런스를 생성할 수 없다.
>
>   > 단, const값에 대해서는 레퍼런스를 생성할 수 있다.
>
> ```c++
> int &bar = 5; // 컴파일 에러
> const int& bar = 5;  // 정상 작동
> ```
>



- 레퍼런스는 타입에 대해서 적용된다.

 ```c++
 int& foo = x;  // int에 대한 레퍼런스
 string& foo = x;  // string에 대한 레퍼런스
 
 int& bar = y;  
 bar = &y;  //컴파일 에러
 y의 주소는 포인터지만, foo는 포인터에 대한 레퍼런스가 아닌 double에 대한 레퍼런스다
     
 foo = bar; // foo가 가리키는 대상이 바뀌지 않고, foo의 값이 y가 된다.
 ```

>레퍼런스는 모든 타입에 대해 만들 수 있다.




- 레퍼런스가 가져온 주소는 그 레퍼런스가 가리키는 변수의 주소와 같다.


```c++
int x = 3;
int& foo = x;
int* bar = &foo;  // x에 대한 레퍼런스의 주소를 가져와서 bar이 x를 가리키도록 설정
*bar = 100;  // x의 값에 100 대입
```

> bar은 int에 대한 포인터 타입, foo는 int에 대한 레퍼런스 타입이므로 `&foo == bar` 또는 `&bar == x`
>
> `int&&`, `int&*`은 불가능



- 레퍼런스 매개변수

레퍼런스는 변수나 데이터 멤버를 별도로 사용할 순 있지만, 주로 함수나 메서드의 매개변수로 많이 사용한다. 

> 매개변수는 값 전달 방식을 따르기 때문에 함수는 인수의 복사본을 받아 인수의 원본은 변하지 않는다. 하지만 매개변수를 레퍼런스 타입으로 선언하면 전달된 값을 수정했을 때 인수로 지정한 원본 변수의 값도 바뀐다.

```c++
int x = 5, y = 6;
swap(x, y);

void swap(int& foo, int& bar) // 매개변수 타입이 레퍼런스로 선언됨
{
    int temp =foo;
    foo = bar;
    bar =foo
}   // 인수로 받은 foo와 bar의 원본이 바뀜

// 같은 함수에 포인터(주소)를 전달해야 할 때
int x = 5, y = 6;  
int *xp = &x, *yp = &y  // 포인터를 역참조해서 전달해야 포인터를 레퍼런스로 변환할 수 있다. 
swap(*xp, *yp);
```

> 레퍼런스 전달 방식은 함수나 메서드 안에서 인수로 전달한 값을 수정하면 그 결과가 원본 변수에도 반영되게 만들고 싶을 때 주로 사용한다.
>
> - 장점
>
> 1. 효율성
>
>    >크기가 큰 객체는 복제 오버해드가 크다. 레퍼런스 전달 방식을 사용하면 객체에 대한 레퍼런스만 함수에 전달할 수 있다. (메모리 절약)
>
> 2. 정확성
>
>    >값 전달 방식을 지원하지 않는 객체, 또는 동적 할당 메모리를 사용하는 객체에 대해서는 깊은 복제를 위해 레퍼런스를 사용한다.
>    >
>    >참고: [class에 관하여](https://github.com/HibernationNo1/TIL/blob/master/study_C%2B%2B/class%EC%97%90%20%EA%B4%80%ED%95%98%EC%97%AC.md)
>    >
>    >복제 생성자, 복제 대입 연산자 부분 확인



### - 레퍼런스 리턴 값

함수나 메서드의 리턴값을 레퍼런스 타입으로 지정하면 객체 전체를 리턴하지 않고 객체에 대한 레퍼런스만 리턴해서 복제 연산을 줄일 수 있기 때문에 효율성이 높아진다.

> 스코프가 자신이 속한 함수나 메서드로 제한되는 로컬 변수(지역 변수)는 레퍼런스로 리턴하면 안된다.





## 2. rvalue 레퍼런스



## 3. 레퍼런스와 포인터

레퍼런스 값은 Null이 될 수 없고, 레퍼런스를 명시적으로 역참조할 수 없기 때문에 포인터보다 훨씬 안전하다.

### - 레퍼런스와 포인터의 선택 기준

- #####  포인터를 사용해야 할 때

  > - 가리키는 위치를 변경해야 할 때(**스마트 포인터 사용**)
  >
  > - 동적 할당 메모리의 주소는 레퍼런스가 아닌 포인터에 저장해야 한다.
  >
  > - 주소값이 nullptr가 될 수도 있는 opional 타입을 사용할 때
  >
  > - 컨테이너에 다형성 타입을 저장할 때
  >
  > 참고 내용 [포인터에 관하여](https://github.com/HibernationNo1/TIL/blob/master/study_C%2B%2B/pointer%EC%97%90%20%EA%B4%80%ED%95%98%EC%97%AC.md)



- ##### 매개변수나 리턴값을 표현할 때

매개변수나 리턴값을 포인터와 레퍼런스 중 어느 것으로 표현하는 것이 적합한지 판단은 메모리의 소유권이 어디에 있는지 따져봐야 한다.

>메모리의 소유권이 변수를 받는 코드에 있으면 객체에 대한 메모리를 해제하는 책임은 그 코드에 있다. 따라서 객체를 포인터로 표현한다.
>
>반면 메모리 소유권이 변수를 받는 코드에 없어서 메모리를 해제할 일이 없다면 레퍼런스로 전달한다.