# 자료구조

## 자료구조에 대해서

#### - 선택 기준

- 자료의 처리 시간
- 자료의 크기
- 자료의 활용 빈도
- 자료의 갱신 정도
- 프로그램의 용이성



#### - 특징

##### 1. 효율성 (Efficiency)

자료구조를 사용하는 목적은 효율적인 데이터의 관리 및 사용이다. 

상황에 맞게 적절한 자료구조를 이용하게 되면 실행시간을 단축시켜주거나 메모리 용량의 절약을 이끌어 낼 수 있다.



##### 2. 추상화 (Abstraction)

추상화란 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려내는 것. 

자료구조를 구현할 때 중요한 것은 어느 시점에 데이터를 삽입하고, 어느 시점에서 이 데이터를 어떻게 사용할 것인지에 대해 초점을 맞출 수 있기 때문에 구현 외적인 부분에 더 시간을 쏟고 알고리즘 자체에는 중점을 두지 않는다.



##### 3. 재사용성 (Reusability)

자료구조를 이용하여 데이터를 처리할 경우 해당 자료구조의 인터페이스만 이용하여 데이터를 처리하도록 하므로 모듈화가 가능하다. 

이는 자료구조를 설계할 때 특정 프로그램에 맞추어 설계하지 않고 다양한 프로그램에서 사용될 수 있도록 범용화하여 설계함으로써 가능하다.



#### - 분류

1. **단순 구조**

   - 정수, 실수, 문자, 문자열 등의 기본 자료형

   

2. **선형 구조** : 자료들 간의 앞뒤 관계가 1:1의 선형관계

   - 배열(Array) : 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료구조
   - 연결 리스트 (Linked List) : 각 노드가 데이터와 포인터를 가지고 한줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조
     - Doubly Linked List : Linked List와 비슷. 각 노드가 앞 뒤의 노드와 연결되어 있는 자료구조 
   - 스택 (Stack) : LIFO (Last In First Out) 나중에 들어온 자료가 먼저 나가는 자료구조
   - 큐 (Queue) : FIFO (First In First Out) 먼저 들어온 자료가 먼저 나가는 자료구조
   - 덱 (Deque) : 양쪽에서 삽입/인출이 가능한 자료구조

   

3. **비선형 구조** : 자료들 간의 앞뒤 관계가 1:N, N:N의 관계

   - 트리 (Tree) :부모 논드 밑에 여러 자식 노드가 연결되고, 자식 노드가 부모가 되어 다시 각각의 자식 노드가 연결되는 재귀적 형태의 자료구조
   - 그래프 (Graph) : 정점(Vertex)과 정점들을 연결하는 변(Edge)로 구성된 자료구조



#### - 시간 복잡도

시간복잡도란 알고리즘을 푸는데에 있어서 종료할 떄 까지의 시간과 공간을 얼마나 차지하는지의 표기법이다

시간복잡도를 계산할 시 발생할 수 있는 최악의 연산 수를 **Big-O nation**으로 표시할 수 있다. 계산시 작은 상수들을 제외하고 큰 지수들만 표시한다(데이터의 크기가 커질 수록 상수가 성능의 흐름에 크게 상관없어지고, 알고리즘의 러닝타임을 정확하게 표시한다기 보단 데이터나 사용자의 증가율에 따른 알고리즘의 성능을 예측하는 것이 목표이기 때문이다)

- **O(1) (constant)**

  입력데이터의 크기에 상관없이 언제나 처리속도는 동행하게 이루어진다.

  > ex) sorted Array search

- **O(log n) (logarithmic)**

  입력데이터의 크기가 커지더라도 처리속도가 크게 달라지지 않으며, 실행시간이 지날수록 처리해야 하는 데이터의 양이 절반으로 줄어드며 실행 시간은 증가하지만 속도는 감소한다.

  > ex) Binary search

- **O(n) (linear)**

  입력데이터의 크기에 비례해서 처리시간이 증가해 메모리의 사용이 정비례 한다(step : size = 1 : 1).

  > ex) search linked list, for문을 이용한 array 검색

- **O(n^2) (quadratic)**

  입력데이터의 크기에 따라 걸리는 시간은 제곱에 비례한다.

  > ex) 이중 for문

- **O(C^n) (exponential)**

  문제를 해결하기 위한 단계의 수는 주어진 상수값 C의 n제곱이다.

  > ex) 피보나치 수열, recursion



## 선형 자료구조

### 1. Array

#### 1. 특징

> - 같은 타입의 데이터를 나열한다.
> - index로 식별 /조회가 가능하다.
> - 연속된 메모리 공간에 순차적으로 저장한다.
> - 배열의 크기가 고정이다.



#### 2. 장점

>- 논리적 순서와 물리적 순서가 일치하기 때문에 index값을 통한 원소 접근이 용이하고 구현이 쉽다.
>
>- 연속된 메모리 공간에 존재하기 때문에 관리하기 편하다.



#### 3. 단점

>- 삽입, 삭제 등과 같은 연산이 비효율적. 
>
>  >- 삽입: 삽입한 인덱스를 포함한 그 뒤에 인덱스들에 대한 shift연산을 해줘야 한다.
>  >- 삭제: 순서를 맞추기 위해 뒤의 원소들을 모두 앞으로 shift연산을 해줘야 함
>
>- 배열의 크기를 바꿀 수 없다.
>
>- 연속된 메모리라서 중간의 데이터가 삭제되거나 배열 크기보다 작은 index만 사용하면 공간 낭비가 된다.
>
>- 연속적인 메모리 할당이 필요해서 메모리 공간을 많이 사용함



#### 4. 시간 복잡도

> - 탐색 연산: O(1)
>
> 데이터의 위치를 알고 있기 때문에 검색을 하지않고 바로 접근 할 수 있다.
>
> 만약 데이터의 위치를 알고 있지 않다면, array의 index를 하나하나씩 살펴보아야 하며 최악의 경우 데이터의 갯수(n)만큼 찾아야 한다
>
> - 할당: O(1)
>
> 데이터를 덮어 씌울 때 또한 데이터의 위치를 알고 있기 때문에 바로 접근이 가능하다
>
> - 삽입 / 삭제
>
>   >- array의 맨 앞을 삽입/삭제: O(1)
>   >- array의 맨 뒤에 삽입/삭제: O(1)
>   >- array의 중간에 삽입/삭제: O(n) (shift 시간)
>   >
>   >데이터를 삽입하려 할 때 그 index의 공간을 확보해야 하기 때문에 다른 데이터들의 자리를 하나씩 옮겨야 한다



#### 5. 사용하는 경우

> - 데이터 개수가 정해져 있을 때
> - 데이터의 삭제와 삽입이 적을 때
> - 검색을 해야할 때



- 추후 동적배열에 대한 글 추가 예정



### 2. Linked List

#### 1. 특징

> - 불연속적 메모리 공간에 저장. 
>
> - 각 원소는 노드(Node) 라고 부른다.
>
> - 노드를 연결하여 형성되어 있다.
>
>   >- 첫번째 노드를 헤드(Head, 머리), 마지막 노드를 테일(Tail, 꼬리)이라고 함.
>   >-  각 노드는 데이터와 다음 노드를 가리키는 포인터로 이루어짐.
>
> - 크기가 고정되어 있지 않다.
>
> - index를 바로 참초가 불가능하고 노드들의 순서를 통해 원하는 노드에 도달할 수 있다. 



#### 2. 장점

>- 크기가 고정되어 있지 않아 새로운 요소를 추가할 때 크기 제한에서 자유롭다.
>
>- 사용한 메모리 재사용이 가능하고 데이터를 빈 틈 없이 저장한다.



#### 3. 단점

>- index 접근이 불가능해 원소를 탐색할 때 Direct Access 불가능(n번 index를 참조하려면 1번부터 n번까지 차례로 접근해야 한다.)
>- 포인터로 인해 저장 공간의 낭비가 심하다.
>- 탐색할 때 반복자를 이용하여 검색하기 때문에 성능 구림



#### 4. 시간 복잡도

> - 탐색 연산: O(n)
>
> random으로 주소를 알고 있기 때문에 바로 접근이 불가능하고 head부터 찾기 시작해야 한다. 따라서 원하는 노드가 나올때까지 찾아야 하며 최악의 경우 데이터의 갯수(n)만큼 검색해야 한다.
>
> - 할당: O(n)
>
> head에서부터 찾기 시작하며 최악의 경우 데이터의 갯수(n)만큼 검색해야 한다.
>
> - 삽입 / 삭제
>
>   >- list의 맨 앞을 삽입/삭제: O(1)
>   >- 배열의 맨 뒤에 삽입/삭제: O(1)
>   >
>   >head 또는 tail에서 붙이거나 삭제한다면 바로 접근이 가능하다. 따라서 본인의 노드를 head 또는 tail에 연결하면 된다.
>   >
>   >- 배열의 중간에 삽입/삭제: O(n) (탐색 시간)
>   >
>   >데이터를 중간에 제거하는 경우 내가 삭제하려는 노드의 위치는 알지만 내 전후의 노드들을 서로 연결시켜줘야 할때 연결하려는 이전 노드를 알지 못하기 때문에 탐색시간이 걸린다.



#### 5. 사용하는 경우

> - 크기가 유동적일때
> - 삽입과 삭제가 자주 일어날 때
> - 검색을 자주 하지 않을 때



### 3. Doubly Linked List

#### 1. 특징

> - 각 노드가 다음 노드(next)와 이전 노드(previous)를 가리지는 포인터를 가지고 있다.
> - Linked List에 비해 메모리를 더 사용하지만 양방향 탐색이 가능하다.



#### 2. 장점

>- List 확장이 용이함
>- 노드를 탐색하는 방향이 양쪽으로 가능. 즉 높은 index의 값을 찾을 때 역방향으로 탐색이 가능



#### 3. 단점

>- 한 노드의 포인터가 잘못됐을 경우 다른 노드에 접근할 수 없게 될 가능성이 있음
>- 구현이 Linked List보다 복잡하다.



#### 4. 시간 복잡도

> - 탐색 연산: O(n)
>
> - 삽입 / 삭제
>
>   >- list의 맨 앞을 삽입/삭제: O(1)
>   >- 배열의 맨 뒤에 삽입/삭제: O(1)
>   >- 배열의 중간에 삽입: O(n) 
>   >- 배열의 중간에 삭제: O(1) 
>   >
>   >remove의 경우 데이터의 위치를 모두 알고 있기 때문에 검색없이 바로 제거가 가능하다.



#### 5. 사용하는 경우

> - Linked List 보다 대부분 Doubly Linked List를 사용함



### 4. Stack

#### 1. 특징

> - 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 FILO(First In Last Out) 형태
> - 스택에 데이터를 push 하면 항상 top에 들어가고, pop 하면 가장 최근에 푸시한 데이터가 나온다.
> - 가장 아래 자료를 Bottom이라고 한다. (bottom의 index는 -1이다.)
> - 맨 위 요소만 접근할 수 있음.



#### 2. 장점

>- 데이터의 삽입과 삭제가 빠르다
>- 구조가 단순하고 구현이 쉽다.



#### 3. 단점

>- 크기를 미리 정해놓아야 한다. 사이즈 이상을 push할 때 Overflow발생
>- index로 임의 원소 접근이 불가능하다. (접근은 맨 위의 원소만 가능)
>- 크기가 불확실할 때, 확장시 확장연산이 오래걸린다.
>- 데이터의 put(넣기), pop(빼기)가 한 쪽에서만 가능하다. 



#### 4. 시간 복잡도

> - 탐색 연산: O(n)
> - 원소를 삽입/삭제하는 경우: O(1)



#### 5. 사용하는 경우

> - 재귀 알고리즘
> - 역추적을 해야할 때



### 5. Queue

#### 1. 특징

> - 한 쪽 끝에서만 자료를 넣고 반대쪽에서만 뺄 수 있는 FIFO(First In First Out) 형태
> - 데이터가 삽입(push)되는 곳을 front, 제거(pop)되는 곳을 back이라고 한다.



#### 2. 장점

>- 데이터의 삽입/삭제가 빠르다.



#### 3. 단점

>- queue의 중간에 위치한 데이터로의 접근이 어렵다.
>- 데이터를 삭제하는 경우
>  - Front는 고정, Back을 이동하면서 데이터를 삭제하는 경우: 데이터를 제거했을 때, 나머지 데이터를 한 칸씩 다 옮겨야 함.
>  - 둘 다 이동하면서 삽입, 삭제를 할 경우 : 배열의 끝에 저장되어 있는 상황이면, Back을 더 이상 이동시킬 수 없어서 overflow 발생.



#### 4. 시간 복잡도

> - 원소를 삽입/삭제하는 경우: O(1)



#### 5. 사용하는 경우

> - 데이터를 입력된 순서대로 처리해야 할 때
> - BFS (너비 우선 탐색) 구현할 때



### 6. Deque

#### 1. 특징

> - 양 쪽 끝에서 자료를 넣는것과 빼는것이 전부 가능
> - 연속적인 메모리를 기반으로 하는 '시퀀스 컨테이너'이다. 따라서, 임의 접근 반복자 제공
> - 중간 요소가 삽입, 삭제될 때, 요소들을 앞/뒤로 밀 수 있다.
> - 

#### 2. 장점

>- 데이터의 삽입/삭제가 빠르다.
>- 앞, 뒤에서 데이터를 삽입/삭제할 수 있다.
>- 크기가 가변적이다. (선언 후에 변경할 수 있다.)
>- index로 임의 원소 접근이 가능하다.
>- 새로운 원소 삽입 시에, 메모리를 재할당하고 복사하지 않고 새로운 단위의 메모리 블록을 할당하여 삽입한다.



#### 3. 단점

>- Dueue의 중간에 위치한 데이터로의 접근이 어렵다.
>- 앞/뒤에서의 삽입/삭제 성능은 좋지만 중간에 위치한 데이터 삭제는 효율이 좋지 않다.
>- 구현이 어렵다.



#### 4. 시간 복잡도

> - 탐색 : O(1) (index 접근)
> - 원소를 앞/뒤에 삽입 또는 삭제하는 경우 : O(1)



#### 5. 사용하는 경우

> - 앞과 뒤에서 삽입, 삭제가 자주 일어나는 경우
> - 데이터의 개수가 가변적일 경우
> - 데이터 검색을 거의 하지 않을 경우 (랜덤 요소에 접근해야할 때)



## 비선형 자료구조

### 1. Tree



>  Binary Tree

>  BST, Binary Search Tree

>  Red Black Tree

HashTable

Graph