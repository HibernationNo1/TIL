# 질문



### MLOPs질문

- **MLOPs란 무엇이며, 장점에 대해서 설명해주세요**

  머신 러닝 프로젝트의 개발, 배포, 운영, 유지보수, 모니터링 등 전체 머신 러닝 라이프사이클을 효율적으로 관리하는 프로세스와 방법론을 의미합니다.

  장점이라기보단, MLOPs체계를 구축하는 팀의 목표를 말씀드리는게 좋을 것 같습니다.

  CI/CD를 활용하여 모델의 지속적인 통합과 배포를 지원하므로 개발 생산성이 향상됩니다.

  모델의 코드, 데이터, 환경 설정 등을 버전 관리하기 때문에 모델의 변경 내역을 추적하여 실험과 결과를 재현할 수 있습니다.

  모델의 배포와 운영을 자동화하고 효율화합니다.

  팀 협업을 강화합니다. 개발자, 데이터 과학자, 운영팀이 모델 라이프사이클 전반에 걸쳐 효과적으로 협업할 수 있도록 지원하며, 모델 개발과 운영을 하나의 통합된 프로세스로 관리할 수 있습니다.

  

- **모델 드리프트가 무엇인가요?**

   머신 러닝 모델이 실제 환경에서 사용되는 데이터와 학습에 사용된 데이터 사이의 차이로 인해 모델의 성능이 저하되는 현상을 말합니다.

  모델이 학습될 때 사용된 데이터는 일반적으로 과거의 데이터이며, 실제 운영 환경에서 사용되는 데이터는 시간이 지남에 따라 변화할 수 있습니다. 따라서 모델이 새로운 데이터에 대해 잘 작동하지 않게 되는데, 이를 모델 드리프트라고 합니다.

  

- **CI/CD에 대해서 설명해주세요**

  Continuous Integration/Continuous Deployment의 준말로, 개발, 테스트, 배포를 자동화하여 개발자들이 효율적으로 소프트웨어를 제공하고, 빠르게 배포하며, 높은 품질과 안정성을 유지할 수 있도록 하는 방법론이나 접근 방식입니다.

  - CI는 개발자들이 코드를 작성하고, 수정하고, 새로운 기능을 추가할 때마다 코드를 주기적으로 빌드하고 테스트하는 프로세스를 자동화하는 것을 의미합니다. CI는 개발자들이 빈번하게 코드를 통합하고, 버그를 조기에 발견하며, 코드 품질을 지속적으로 개선할 수 있도록 도와줍니다.
  - CD는 CI의 결과물인 빌드된 소프트웨어를 자동으로 운영 환경으로 배포하는 프로세스를 의미합니다. Continuous Deployment는 자동화된 테스트와 배포 파이프라인을 통해 개발자들이 작성한 코드 변경사항을 실제 운영 환경에 신속하게 반영하는 것을 의미합니다. 

- 정적 배포와 동적 배포의 차이점을 설명해주세요

  - 정적 배포는 소프트웨어를 빌드하여 실행 파일이나 라이브러리 형태로 패키징한 후, 이를 운영 환경에 배포하는 방식을 의미합니다.
    - 빌드된 실행 파일이나 라이브러리를 운영 환경에 배포하므로 런타임 환경에 대한 의존성이 적습니다.
    - 배포된 소프트웨어는 고정된 상태로 동작하기 때문에, 런타임에 의존하는 요소의 업데이트가 필요 없습니다.
    - 소프트웨어가 더 빠르게 실행되는 장점이 있습니다.
  - 동적 배포는 소프트웨어를 개발 단계에서부터 런타임 환경까지 유동적으로 관리하여, 실행 중에 필요한 모듈이나 라이브러리를 동적으로 로드하고 업데이트하는 방식을 의미합니다. 이는 소프트웨어를 보다 유연하고 확장 가능하게 만들어줍니다.
    - 런타임에 필요한 모듈이나 라이브러리를 동적으로 로드하므로, 운영 환경에 더 많은 의존성이 있을 수 있습니다.
    - 런타임에 새로운 모듈이나 기능을 추가하거나 업데이트하는 것이 가능합니다.
    - 동적 배포는 보다 유연하며, 컴포넌트들 사이의 의존성을 느슨하게 만들어줍니다.

  

- **cri-dockerd에 대해서 설명해주세요**

  Container Runtime Interface (CRI)를 구현하기 위한 도커 데몬(Docker daemon)입니다.

   이를 통해 Kubernetes는 다양한 컨테이너 런타임을 지원하고, 컨테이너의 생성, 시작, 종료, 모니터링 등을 통일된 방식으로 관리할 수 있습니다.

  `cri-dockerd`를 사용하면 Kubernetes 클러스터에서 기존에 사용하던 도커와 동일한 방식으로 컨테이너를 관리할 수 있으면서, 다른 CRI를 구현한 컨테이너 런타임으로 전환하는 것도 가능합니다. 이는 Kubernetes가 여러 컨테이너 런타임을 지원하고 확장성을 갖추는 데 도움을 주는 중요한 요소입니다.

  

- **docker에 대해서 간단히 설명해주세요.**

  컨테이너화 기술을 제공하는 오픈 소스 플랫폼으로, 애플리케이션을 컨테이너라는 단위로 패키징하고 배포하는 것을 도와줍니다. 

  컨테이너는 격리된 환경에서 애플리케이션과 그에 필요한 라이브러리, 설정 등을 함께 묶어 실행할 수 있는 가볍고 이식성이 높은 단위입니다.

  1. 도커 엔진 (Docker Engine): 컨테이너를 생성, 실행, 관리하는 핵심 엔진입니다. 컨테이너 런타임과 이미지 빌더 등의 기능을 포함하고 있습니다.
  2. 도커 이미지 (Docker Image): 컨테이너를 실행하기 위한 실행 가능한 패키지입니다. 애플리케이션과 필요한 모든 설정, 라이브러리 등이 이미지로 패키징되어 있습니다.
  3. 도커 컨테이너 (Docker Container): 도커 이미지를 기반으로 실행되는 실행 단위입니다. 격리된 환경에서 애플리케이션이 실행되며, 호스트와 독립적으로 동작합니다.
  4. 도커 레지스트리 (Docker Registry): 도커 이미지를 저장하고 공유하기 위한 저장소입니다. 도커 허브(Docker Hub)는 가장 잘 알려진 도커 레지스트리 중 하나입니다.

  

- **kubernetes에 대해서 간단하세 설명해주세요**

   컨테이너 오케스트레이션(Orchestration) 시스템으로, 여러 대의 서버에 분산되어 실행되는 컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화하는 오픈 소스 플랫폼입니다.

  1. 컨테이너 오케스트레이션: 쿠버네티스는 여러 개의 컨테이너를 노드(서버)들에 자동으로 분산 배포하고, 컨테이너 간의 통신, 확장, 관리를 자동으로 처리합니다.
  2. 자동화: 쿠버네티스는 노드의 상태를 감지하고 필요에 따라 컨테이너를 자동으로 스케일링하고 장애 복구를 수행합니다.
  3. 서비스 디스커버리: 쿠버네티스는 애플리케이션의 서비스들을 동적으로 발견하고 서로 통신할 수 있도록 지원합니다.
  4. 롤링 업데이트: 쿠버네티스는 애플리케이션을 중단시키지 않고 롤링 업데이트를 수행하여 애플리케이션을 무중단으로 업데이트할 수 있습니다.
  5. 확장성: 쿠버네티스는 수천 개의 노드와 수백만 개의 컨테이너를 다룰 수 있는 높은 확장성을 가지고 있습니다.
  6. 포팅 가능성: 쿠버네티스는 다양한 클라우드 프로바이더나 온프레미스 환경에 쉽게 배포할 수 있으며, 다양한 컨테이너 런타임을 지원합니다.
  7. 선언적 구성: 쿠버네티스는 YAML 파일 등으로 애플리케이션의 구성을 선언적으로 정의하여 관리할 수 있습니다.

- **Kubernetes의 Master Node와 Worker Node에 대해서 각각 개념과 차이점에 대해서 설명해주세요.**

  - Master Node:

    Master Node는 쿠버네티스 클러스터의 제어 플레인을 담당하며, 클러스터의 전반적인 관리와 제어를 담당합니다.

    - Master Node는 쿠버네티스 클러스터의 제어 플레인(Control Plane)을 담당하는 노드입니다.
    - API 서버, 스케줄러(Scheduler), 컨트롤러 매니저(Controller Manager), etcd 데이터베이스가 포함됩니다.

  - Worker Node:

    Worker Node는 실제 컨테이너가 실행되는 노드로, 파드들이 배포되고 실행되는 곳입니다. 컨테이너들의 실행과 상태 보고를 담당합니다.

    - Worker Node는 실제로 컨테이너가 실행되는 호스트 머신입니다.
    - 컨테이너 런타임(Docker, containerd 등), kubelet, kube-proxy 등의 구성 요소가 포함됩니다.
    - 컨테이너 런타임은 컨테이너를 실행하고 관리하는 역할을 합니다.
    - kubelet은 Master Node와 통신하여 할당된 파드를 실행하고 노드의 상태를 보고하는 역할을 합니다.
    - kube-proxy는 파드 간의 네트워크 통신을 관리하는 역할을 합니다.

  

- **cluster에 대해서 설명해주세요**

  클러스터(Cluster)는 여러 대의 컴퓨터 또는 서버가 네트워크로 연결되어 하나의 시스템으로 동작하는 컴퓨터 시스템의 집합을 의미합니다. 클러스터는 다수의 노드(Node)가 함께 작동하여 고성능 및 고가용성을 제공하고, 일부 노드의 장애에도 전체 시스템이 동작할 수 있는 내결함성을 가집니다.

  

- **pod에 대해서 설명해주세요. docker container와의 차이점도 설명해주세요.**

  파드(Pod)는 쿠버네티스(Kubernetes)에서 가장 작은 배포 단위이며, 하나 이상의 컨테이너를 포함하는 쿠버네티스 오브젝트입니다.

  1. 독립성: 각 파드는 고유한 IP 주소와 호스트명을 가지며, 자체적으로 컨테이너를 실행하고 관리합니다.
  2. 공유 네트워크와 스토리지: 파드 안의 컨테이너는 동일한 네트워크 네임스페이스와 스토리지 볼륨을 공유합니다. 따라서 컨테이너들은 서로 통신하거나 데이터를 공유하는 데 용이합니다.
  3. 단일 로그 및 이벤트: 파드 안의 모든 컨테이너들은 동일한 로그와 이벤트를 공유합니다.

  > Docker 컨테이너는 단일 컨테이너를 실행하기 위해 사용되는 단위로, 단일 프로세스를 실행하거나 애플리케이션의 일부를 담당합니다. 반면 쿠버네티스 파드는 다중 컨테이너를 함께 묶어서 하나의 논리적인 단위로 실행하고, 컨테이너들 사이에 네트워크와 스토리지를 공유할 수 있습니다.

  

- **kubernetest의 namespace에 대해서 설명해주세요**

  쿠버네티스 클러스터 내에서 리소스를 그룹화하는 가상의 공간입니다. 네임스페이스를 사용하여 리소스를 논리적으로 분리하고 충돌을 방지할 수 있습니다. 

  

- **kubernetest의  service에 대해서 설명해주세요**

  파드는 동적으로 생성되고 삭제될 수 있으며, 각 파드는 고유한 IP 주소를 가지지만 이 IP 주소는 파드가 삭제되거나 재시작될 때마다 변경될 수 있습니다. 서비스는 이러한 파드들의 앞단에 위치하여 고정된 IP 주소와 DNS 이름을 제공하여 클라이언트가 파드에 접근하고, 파드들 간에 통신할 수 있도록 합니다.

  

- **kubernetest의  load balanser에 대해서 설명해주세요**

  쿠버네티스의 로드 밸런서는 서비스를 외부에 노출하기 위한 매커니즘으로 사용됩니다. 서비스를 로드 밸런서 유형으로 설정하면, 클러스터 외부에서 서비스에 접근할 수 있도록 외부 IP 주소를 할당합니다.

  

- **kubernetest의  Persistent Volume  Claim(PVC)에 대해서 설명해주세요**

  쿠버네티스의 Persistent Volume Claim(PVC)은 영구적인 스토리지 볼륨을 동적으로 할당하기 위한 요청을 나타내는 리소스입니다. PVC를 사용하여 파드가 지속적으로 유지되지 않고 삭제되어도 데이터가 보존되도록 스토리지를 동적으로 할당할 수 있습니다

  

- **kubernetest의  secret에 대해서 설명해주세요**

  쿠버네티스의 시크릿(Secret)은 암호화된 데이터를 저장하는 데 사용되는 리소스입니다. 주로 패스워드, 토큰, 인증서 등의 민감한 정보를 저장하는 데 사용됩니다. 시크릿은 Base64로 인코딩되어 저장되기 때문에 보안적으로 안전하게 저장됩니다. 

  

- **kubernetest의 Taints와 Tolerations에 대해서 설명해주세요**

  쿠버네티스의 Taints와 Tolerations은 노드와 파드 간의 관계를 조정하는 메커니즘입니다. 

  - Taints는 특정 노드에 특정 조건을 설정하여 파드가 해당 노드에 스케줄링되지 않도록 하는 것을 의미합니다. 
  - Tolerations는 파드가 특정 노드에 스케줄링될 때 해당 노드의 Taints를 허용하는 것을 의미합니다. 

  이를 통해 특정 노드에 파드를 할당하여, 파드와 노드 간의 특별한 제약 조건을 지정할 수 있습니다. 이는 특정 노드에만 특정 파드를 배치하거나, 노드에 대한 특정 설정을 적용하고자 할 때 유용하게 사용됩니다.

  

- **Kubernetes 클러스터 모니터링 방법에 대해서 설명해주세요**

  클러스터 모니터링은 클러스터 내의 리소스 사용, 상태, 성능 등을 지속적으로 감시하고 분석하여 클러스터의 안정성과 가용성을 유지하는 중요한 작업입니다. 클러스터 모니터링을 통해 리소스 사용량, 애플리케이션 성능, 노드 상태 등을 파악하여 이슈를 조기에 감지하고 대응할 수 있습니다. 

  - Kubernetes 모니터링

    Kubernetes에서 제공하는 모니터링 기능은 클러스터 내부의 다양한 리소스를 추적하고 상태를 확인하는 기능을 포함합니다. 

  - Prometheus 모니터링

    Prometheus는 CNCF(Cloud Native Computing Foundation)에 의해 개발되고 유지되는 오픈 소스 모니터링 시스템입니다. Prometheus는 다양한 서비스 및 시스템에서 메트릭을 수집하고 쿼리하고 시각화하는 데 사용됩니다. 

  

- **클라우드에서 K8s를 운영할때 어떤 이점을 가질 수 있는지 설명해주세요**

  1. **스케일링과 자동화:**
     - 클라우드에서 K8s를 운영하면 필요에 따라 리소스를 신속하게 확장하거나 축소하여 애플리케이션의 성능과 가용성을 최적화할 수 있습니다. 또한 클라우드 제공자의 자동화 기능을 통해 클러스터 관리 작업을 자동화할 수 있습니다.
  2. **유연성과 탄력성:**
     - 클라우드 환경에서 K8s를 운영하면 필요에 따라 리소스를 쉽게 조정할 수 있어 애플리케이션의 요구사항에 유연하게 대응할 수 있습니다. 이는 비즈니스의 변화에 더 빠르게 대응할 수 있음을 의미합니다.
  3. **높은 가용성과 안정성:**
     - 클라우드 서비스 제공자는 여러 데이터 센터에 걸쳐 복제된 서버를 제공하여 높은 가용성과 안정성을 보장합니다. 이를 통해 애플리케이션의 장애 복구 및 이중화를 지원합니다.
  4. **관리의 용이성:**
     - 클라우드 제공자는 K8s 클러스터의 배포, 업그레이드, 모니터링, 로깅 등의 관리를 담당하여 기업은 서비스에 집중할 수 있습니다.