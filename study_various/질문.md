# 질문





### CS 질문

- **logical address와 physical address의 차이에 대해서 설명해주세요**

  logical address는 memory의 특정 공간에 대한 주소를 어디 있는지 확인하기 쉽게 process별로 0번지부터 차례로 이름을 붙여주는 것이고(별명처럼)

  physical address는 process가 실제로 memory에 적재되는 위치를 나타내는 주소이다.

  

- **memory 관리 기법 중 paging에 대해서 설명해주세요**

  우선 프로그램을 일정 크기의 page로 분할한다. physical memory또한 page와 같은 크기의 frame으로 분할한다.

  이후 page는 각각의 frame에 할당되고, page의 logical address들과 Ram memory의 physical address를 대응해서 저장하는 page table을 만든다.

  이제 메모리는 필요에 따라 페이지 단위로 로드되고 스왑될 수 있게 된다.  이를 page기법이라고 한다.

  이를 통해 가상 메모리 크기가 실제 물리 메모리보다 큰 경우에도 프로세스 실행이 가능하며, 여러 프로세스 간의 메모리 공간을 분리하여 보호할 수 있다.

  - 단, process주소 공간의 크기가 page크기의 배수라는 보장이 없기 때문에, process의 주소 공간 중 가장 마지막에 위치한 page에서는 결국 어느정도 남는 공간(아무 data도 없는 공간)이 발생하게 되는데, 이런 경우를 memory internal fragmentation(memory 내부 단편화)이라고 한다.

  이러한 메모리 관리 기법은 운영체제의 커널에 의해 구현되고 관리된다.

  

- **memory 관리 기법 중 segmentation에 대해서 설명해주세요**

  memory를 segment단위로 나누는 기법이다. 이 때 segment란 코드, 데이터, 스택 등과 같은 프로그램의 논리적인 크기를 의미한다. 때문에 가변적인 크기를 가지며, 프로세스의 요구에 따라 세그먼트를 동적으로 생성하거나 제거할 수 있다.

  이 때 segment의 logical address, physical address, 접근 권한 등을 저장하는 데이터 구조인 Segment Table을 만들게 되는데, 이 table은 logical address를 physical address로 매핑하는 역할을 한다.

  Segmentation은 대규모 프로세스의 메모리 요구 사항을 효율적으로 관리하고 보호하기 위해 사용되며, 특히 다중 프로그래밍 환경에서 유용합니다.

  - 단, 커다란 크기의 segment가 할당되었다가 제거되고 그 자리에 더욱 작은 segment가 할당되면, 기존의 segment에 비해 남는 공간이 생기게 된다. 

    memory external fragmentation(memory 외부 단편화)라고 한다.

  

- **memory 관리 기법 중 paged segmentation에 대해서 설명해주세요**

  segmentation을 기본으로 하되, 각각의 segmentation을 다시 동일 크기의 page로 나누어 physical memory에 할당하는 memory관리 기법이다.

  이를 통해 memory external fragmentation를 해결할 수 있다.

  

- **memory 관리 기법 중 virtual memory에 대해서 설명해주세요**

  프로그램을 page단위로 쪼개고, 사용되는 일부 page만 메모리에 로드하고 그 외 당장에 사용하지 않는 page는 하드 디스크에서 유지하고 있는다. 이후 프로세스가 실행되면서 필요한 page가 요청되면 운영체제는 해당 page를 하드 디스크에서 메모리로 load한다.

  이를 통해 물리적인 메모리 용량보다 큰 프로그램을 실행할 수 있다.

  또한 각 프로세스는 독립된 메모리 공간을 할당받으며, 다른 프로세스의 메모리에 접근할 수 없기 때문에 프로세스 간의 데이터 보호와 안정성을 유지할 수 있다.

  

- **memory의 구조과 각 영역에 대해서 설명해주세요**

  1. **레지스터(Register):**
     - 레지스터는 CPU 내부에 있는 가장 빠른 메모리로, 프로세서가 직접 접근할 수 있는 영역입니다.
     - CPU가 명령어를 실행하고 데이터를 처리하는 데에 필요한 정보를 일시적으로 저장하는데 사용됩니다.
     - 레지스터는 매우 제한적인 용량을 가지며, 프로세서의 아키텍처에 따라 다양한 종류의 레지스터가 있습니다.
  2. **캐시(Cache):**
     - 캐시는 메모리의 레지스터와 RAM 사이에 위치하여 데이터를 더 빠르게 액세스할 수 있도록 도와주는 임시 저장소입니다.
     - CPU가 레지스터에서 데이터를 가져오는 속도보다 빠르게 데이터를 가져올 수 있도록하여 프로그램 실행 속도를 향상시킵니다.
     - 캐시는 여러 계층으로 나뉘어 있으며, 레벨이 높을수록 더 작은 용량의 캐시가 더 빠르게 동작합니다.
  3. **RAM(Random Access Memory):**
     - RAM은 컴퓨터의 주 메모리로, 프로그램이 실행되는 동안 필요한 데이터와 명령어를 저장합니다.
     - RAM은 읽고 쓰기가 빠르며, 데이터를 일시적으로 저장하므로 전원이 꺼지면 저장된 데이터가 사라집니다.
     - 컴퓨터가 켜진 동안 프로그램의 실행과 데이터의 저장에 사용됩니다.
  4. **가상 메모리(Virtual Memory):**
     - 가상 메모리는 RAM과 하드 디스크 사이에 위치하여 물리적으로 부족한 메모리를 보조하는 역할을 합니다.
     - 실제로는 하드 디스크에 있는 일부 공간을 RAM 확장 영역으로 사용하여 프로그램이 필요한 데이터를 주 메모리처럼 사용할 수 있게 합니다.
     - 가상 메모리를 사용하면 물리적인 RAM 이상의 메모리를 사용하는 것처럼 보이게 되므로, 더 큰 프로그램을 실행할 수 있게 됩니다.
  5. **하드 디스크(Hard Disk):**
     - 하드 디스크는 비휘발성 데이터를 저장하는 메모리로, 전원이 꺼져도 데이터가 보존됩니다.
     - 프로그램과 데이터의 장기 저장소 역할을 하며, 운영체제와 응용 프로그램 등이 저장됩니다.

  

- **Process의 개념과 실행되는 과정에 대해서 설명해주세요.**

  process란 실행중인 program이라고 할 수 있는데, 이는 실행파일(program)이 memory에 load되어 CPU를 할당받아 실행(연산)되는 것을 의미한다.

  program이 memory에 load되면, 해당 memory의 code영역에 기계어로 번역된 program의 명령어들이 저장되게 된다.

  이 때 CPU내부의 program counter register는 첫 번째 명령어의 주소값이 저장된다.

  이후 CPU는 program counter register로부터 주소를 받아 해당 명령어를 읽어오고 연산을 실행한다. program counter register는 CPU연산이 시작되면 다음 순서의 명령어 주소를 저장한다.

  위 과정이 반복되며 program이 실행되고, 이를 process라고 한다.

  

- **Thread에 대해서 설명해주세요.**

  Thread는 한 process내에서 실행되는 동작을 의미하며, 독립적으로 함수를 호출하여 기능을 수행하는 것이다.

  즉,  tread는 process가 할당받은 자원을 이용하는 실행의 단위이다.

  

- **HTTP와 HTTPS의 차이를 설명해주세요.**

  http는 암호화되지 않는 text기반 protocol로, 제3자가 네트워크 상에서 데이터를 가로채거나 조작할 수 있다.

  HTTPS는 HTTP의 보안 버전으로, SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security) 프로토콜을 사용하여 데이터를 암호화한다.

  

- **Cookie와 Session에 대해서 설명해주세요.**

  HTTP의 Connectionless(비 연결성)와 Stateless(비 상태성)특성에 의해 server는 client에 대한 상태 정보를 유지하지 않는다.

  하지만 로그인이나 비밀번호 저장과 같은 기능을 사용하기 위해서 Cookie와 Session을 사용할 수 있다.

  Cookie는 client(browser)에 key-value쌍으로 local에 저장되는 data file이다. 유효시간 내에서는 browser가 종료되어도 계속 유지된다.

  user가 따로 작업을 하지 않더라도 browser가 cookie를 request header에 담에서 server에 전송한다.

  Session은 server측에서 저장하여 관리는 인증 data값이다.  사용자 정보를 server에 두기 때문에 cookie보다 보안은 좋지만 server자원을 차지하기 때문에 server에 과부하를 줄 수 있고 성능 저하의 요인이 될 수 있다.

  

- **RDB(Relational Database)에 대해서 설명해주세요**

  관계형 데이터베이스(Relational Database)의 약어로, 데이터를 테이블 형식으로 저장하고 관리하는 데이터베이스 시스템을 의미합니다. 

  RDB는 데이터를 테이블로 구성하며, 각 테이블은 Row로 구성되며, Row는 Column으로 이루어집니다. 

  RDB는 데이터베이스 관리 시스템(DBMS)에 의해 관리되며, SQL(Structured Query Language)을 사용하여 데이터를 조작하고 검색합니다. 

  

- **DW(data warehouse)에 대해서 설명해주세요.**

  DW는 데이터 웨어하우스(Data Warehouse)의 약어로, 기업이나 조직의 다양한 시스템으로부터 추출한 대량의 데이터를 통합하여 저장하고 분석하기 위한 중앙 집계된 데이터 저장소를 의미합니다. DW는 일반적으로 큰 규모의 데이터를 처리하고, 의사 결정에 도움을 주는데 사용됩니다. DW는 정형화된 데이터를 사용하며, OLAP(Online Analytical Processing) 도구를 통해 다차원 데이터 분석을 지원합니다.

  

- **RDB와 DW의 차이점에 대해서 설명해주세요.**

  - 구조와 목적: RDB는 단일 애플리케이션의 데이터 저장과 관리를 위한 데이터베이스로 설계되어 있으며, 비즈니스 로직에 따라 데이터를 저장하고 검색하는데 사용됩니다. 반면 DW는 기업의 다양한 시스템으로부터 대량의 데이터를 통합하여 분석하고 의사 결정에 활용하기 위해 설계되었습니다.
  - 데이터 양과 복잡성: RDB는 상대적으로 작은 규모의 데이터를 다루는데 적합하며, 간단한 스키마 구조를 가지고 있습니다. DW는 대량의 데이터를 처리하고 저장하기 위해 최적화되어 있으며, 다차원 데이터 분석을 위해 복잡한 데이터 모델을 사용합니다.
  - 데이터 특성: RDB는 일반적으로 트랜잭션 데이터(Operational Data)를 다루는데 적합하며, 실시간 처리가 중요한 경우 사용됩니다. DW는 기록적 데이터(Historical Data)를 다루고, 데이터 분석과 의사 결정을 위한 빠른 집계와 쿼리 수행을 지원합니다.

  

  

- **HTTP 메서드에 대해 설명하세요.**

  - **GET:** GET은 서버로부터 데이터를 요청하기 위해 사용되는 메서드입니다. URL에 데이터를 포함하여 전송하며, 주로 데이터를 요청하는데 사용됩니다. 데이터가 URL에 노출되기 때문에 보안적으로 취약하며, 길이에 제한이 있습니다. 또한, 캐시가 가능하여 동일한 요청이 반복되면 캐시된 데이터를 반환할 수 있습니다.

  - **POST:** POST는 서버로 데이터를 제출(전송)하기 위해 사용되는 메서드입니다. 데이터를 요청 바디(Request Body)에 포함하여 전송하며, 주로 데이터를 제출하는데 사용됩니다. 데이터가 URL에 노출되지 않기 때문에 보안적으로 더 안전하며, 길이에 제한이 없습니다. 또한, 캐시되지 않으므로 반복적인 요청에도 항상 새로운 결과를 얻을 수 있습니다.

  - **PUT:** PUT 메서드는 서버에 리소스를 업데이트하기 위해 사용됩니다. 주로 리소스의 전체 내용을 교체하는데 사용되며, 클라이언트가 리소스의 URI를 지정하여 데이터를 업로드합니다.

  - **DELETE:** DELETE 메서드는 서버에 리소스를 삭제하기 위해 사용됩니다. 주로 리소스의 URI를 지정하여 삭제할 리소스를 서버에 요청합니다.

  - **PATCH:** PATCH 메서드는 PUT과 비슷하게 리소스를 업데이트하는데 사용되지만, PUT과 달리 리소스의 일부를 수정하는데 사용됩니다. 클라이언트는 리소스의 일부 변경 사항만 전송하여 업데이트할 수 있습니다.

    HTTP 메서드는 RESTful API와 같은 웹 서비스에서 리소스를 다루는데 중요한 역할을 합니다. 올바른 HTTP 메서드를 사용하여 적절하게 데이터를 요청하고 처리하는 것이 웹 서비스의 안정성과 효율성을 높이는데 기여합니다.

  

- **OSI 7 계층에 대해 설명하세요.**

  - OSI 7 계층은 네트워크 통신을 구성하는 요소들 7개의 계층으로 표준화한 것이다.
  - 표준화하는 것의 장점으로는 통신이 일어나는 과정을 단계별로 파악할 수 있어, 문제가 발생하면 해당 문제를 해결하기 용이해진다.
  - 추가적으로 실제로 우리가 대부분 사용하는 네트워크는 TCP/IP 4 계층이다. 통신에 실제로 사용되는 계층이고 1,2 계층이 1 계층, 5,6,7 계층이 4 계층으로 운영된다.

  

- **TCP와 UDP의 차이점에 대해 설명하세요**

  둘 다 인터넷 프로토콜 스위트의 주요 전송 계층 프로토콜로서 데이터를 컴퓨터 네트워크를 통해 전송하는데 사용됩니다.

  - **연결 지향성 vs 비연결 지향성:** TCP는 연결 지향적인 프로토콜입니다. 데이터를 전송하기 전에 먼저 연결을 설정하고, 데이터를 전송한 후에는 연결을 해제합니다. 이는 데이터의 신뢰성을 보장하며, 데이터의 순서가 보장되어 도착하는 순서대로 재조립됩니다. UDP는 비연결 지향적인 프로토콜이므로 데이터를 전송하기 전에 연결을 설정하지 않습니다. 
  - **신뢰성:** TCP는 데이터를 전송할 때 오류가 발생하거나 데이터가 손실되는 경우, 데이터를 다시 전송하여 신뢰성을 보장합니다. 반면, UDP는 데이터를 전송한 후에 추가적인 확인을 하지 않으므로 오류가 발생해도 데이터를 다시 전송하지 않습니다. 이는 TCP보다 전송 속도가 빠르지만, 데이터의 손실이 발생할 수 있습니다.
  - **사용 용도:** TCP는 데이터의 신뢰성이 중요한 애플리케이션에 주로 사용됩니다. 예를 들어 파일 전송, 이메일, 웹 브라우징 등에 사용됩니다. UDP는 데이터의 신뢰성보다는 전송 속도가 중요한 애플리케이션에 주로 사용됩니다. 예를 들어 실시간 비디오 및 음성 스트리밍, 온라인 게임 등에 사용됩니다.



- **Subnet에 대해서 설명해주세요**

  서브넷(Subnet)은 IP 주소의 논리적인 그룹으로, 하나의 물리적인 네트워크를 여러 개의 작은 네트워크로 분할하는데 사용됩니다. 서브넷을 사용하면 네트워크를 더 효율적으로 관리하고, 트래픽을 분산시킬 수 있습니다. 서브넷은 주로 IP 주소와 함께 서브넷 마스크(Subnet Mask)를 사용하여 표시됩니다.

  

- **Gateway에 대해서 설명해주세요**

  게이트웨이(Gateway)는 한 네트워크에서 다른 네트워크로 데이터를 전달하는 장치 또는 컴퓨터를 의미합니다. 인터넷에 연결된 기기들은 주로 인터넷 게이트웨이를 사용하여 인터넷과 통신합니다. 게이트웨이는 트래픽이 외부 네트워크로 전달되는 지점이며, 라우터가 게이트웨이의 역할을 수행하기도 합니다.

  

- **Traffic에 대해서 설명해주세요**

  트래픽(Traffic)은 네트워크를 통해 전달되는 데이터의 양과 패턴을 의미합니다. 네트워크에서는 데이터 패킷(Packet)이 전송되는데, 이러한 패킷들이 네트워크를 통해 전달되는 흐름을 트래픽이라고 합니다. 트래픽은 네트워크의 성능과 효율성을 평가하는데 중요한 요소입니다.

  

- **DNS에 대해서 설명해주세요** 

  DNS는 도메인 이름과 IP 주소를 매핑하여 인터넷에서 도메인 이름으로 서버를 식별하는 시스템입니다. 사용자가 도메인 이름을 입력하면 DNS는 해당 도메인 이름과 연결된 IP 주소를 찾아서

  

- **프록시에 대해서 설명해주세요**

  프록시(Proxy)는 클라이언트와 서버 간에 중계 역할을 수행하는 서버입니다. 클라이언트가 원격 서버에 직접 접근하지 않고, 프록시 서버를 통해 서버에 접근하도록 설정됩니다. 이를 통해 클라이언트와 서버 사이의 통신을 보안적으로 보호하거나, 네트워크 트래픽을 관리하고 필터링할 수 있습니다.

  프록시 서버는 다양한 목적으로 사용될 수 있습니다:

  1. **보안:** 프록시는 클라이언트의 실제 IP 주소를 숨기고, 대신 프록시 서버의 IP 주소가 서버로 전달됩니다. 이를 통해 클라이언트의 신원을 보호하고, 외부로부터의 직접적인 접근을 막는 보안 기능을 수행합니다.
  2. **캐싱:** 프록시는 이전에 요청된 데이터를 캐싱하여 동일한 요청이 반복될 경우, 캐시된 데이터를 반환합니다. 이를 통해 네트워크 대역폭을 절약하고, 응답 시간을 개선할 수 있습니다.
  3. **트래픽 관리:** 프록시는 트래픽을 관리하고, 네트워크 부하를 분산시키는 기능을 수행합니다. 특정 사이트나 서버로의 트래픽이 몰리는 것을 방지하고, 로드 밸런싱을 지원합니다.
  4. **필터링:** 프록시는 특정 사이트나 콘텐츠에 대한 접근을 제어하고, 웹 필터링을 통해 악성 콘텐츠를 차단하거나 웹 사이트의 접근을 제한할 수 있습니다.



- **트랜잭션에 대해 설명해주세요.**

  트랜잭션은 데이터베이스에서 수행되는 하나의 논리적인 작업 단위를 의미합니다. 

  데이터베이스에서 데이터를 변경하는 작업은 보통 여러 개의 쿼리와 명령어들이 복합적으로 수행되어야 합니다.









### MLOPs질문

- **MLOPs란 무엇이며, 장점에 대해서 설명해주세요**

  머신 러닝 프로젝트의 개발, 배포, 운영, 유지보수, 모니터링 등 전체 머신 러닝 라이프사이클을 효율적으로 관리하는 프로세스와 방법론을 의미합니다.

  장점이라기보단, MLOPs체계를 구축하는 팀의 목표를 말씀드리는게 좋을 것 같습니다.

  CI/CD를 활용하여 모델의 지속적인 통합과 배포를 지원하므로 개발 생산성이 향상됩니다.

  모델의 코드, 데이터, 환경 설정 등을 버전 관리하기 때문에 모델의 변경 내역을 추적하여 실험과 결과를 재현할 수 있습니다.

  모델의 배포와 운영을 자동화하고 효율화합니다.

  팀 협업을 강화합니다. 개발자, 데이터 과학자, 운영팀이 모델 라이프사이클 전반에 걸쳐 효과적으로 협업할 수 있도록 지원하며, 모델 개발과 운영을 하나의 통합된 프로세스로 관리할 수 있습니다.

  

- **모델 드리프트가 무엇인가요?**

   머신 러닝 모델이 실제 환경에서 사용되는 데이터와 학습에 사용된 데이터 사이의 차이로 인해 모델의 성능이 저하되는 현상을 말합니다.

  모델이 학습될 때 사용된 데이터는 일반적으로 과거의 데이터이며, 실제 운영 환경에서 사용되는 데이터는 시간이 지남에 따라 변화할 수 있습니다. 따라서 모델이 새로운 데이터에 대해 잘 작동하지 않게 되는데, 이를 모델 드리프트라고 합니다.

  

- **CI/CD에 대해서 설명해주세요**

  Continuous Integration/Continuous Deployment의 준말로, 개발, 테스트, 배포를 자동화하여 개발자들이 효율적으로 소프트웨어를 제공하고, 빠르게 배포하며, 높은 품질과 안정성을 유지할 수 있도록 하는 방법론이나 접근 방식입니다.

  - CI는 개발자들이 코드를 작성하고, 수정하고, 새로운 기능을 추가할 때마다 코드를 주기적으로 빌드하고 테스트하는 프로세스를 자동화하는 것을 의미합니다. CI는 개발자들이 빈번하게 코드를 통합하고, 버그를 조기에 발견하며, 코드 품질을 지속적으로 개선할 수 있도록 도와줍니다.
  - CD는 CI의 결과물인 빌드된 소프트웨어를 자동으로 운영 환경으로 배포하는 프로세스를 의미합니다. Continuous Deployment는 자동화된 테스트와 배포 파이프라인을 통해 개발자들이 작성한 코드 변경사항을 실제 운영 환경에 신속하게 반영하는 것을 의미합니다. 

- 정적 배포와 동적 배포의 차이점을 설명해주세요

  - 정적 배포는 소프트웨어를 빌드하여 실행 파일이나 라이브러리 형태로 패키징한 후, 이를 운영 환경에 배포하는 방식을 의미합니다.
    - 빌드된 실행 파일이나 라이브러리를 운영 환경에 배포하므로 런타임 환경에 대한 의존성이 적습니다.
    - 배포된 소프트웨어는 고정된 상태로 동작하기 때문에, 런타임에 의존하는 요소의 업데이트가 필요 없습니다.
    - 소프트웨어가 더 빠르게 실행되는 장점이 있습니다.
  - 동적 배포는 소프트웨어를 개발 단계에서부터 런타임 환경까지 유동적으로 관리하여, 실행 중에 필요한 모듈이나 라이브러리를 동적으로 로드하고 업데이트하는 방식을 의미합니다. 이는 소프트웨어를 보다 유연하고 확장 가능하게 만들어줍니다.
    - 런타임에 필요한 모듈이나 라이브러리를 동적으로 로드하므로, 운영 환경에 더 많은 의존성이 있을 수 있습니다.
    - 런타임에 새로운 모듈이나 기능을 추가하거나 업데이트하는 것이 가능합니다.
    - 동적 배포는 보다 유연하며, 컴포넌트들 사이의 의존성을 느슨하게 만들어줍니다.

  

- **cri-dockerd에 대해서 설명해주세요**

  Container Runtime Interface (CRI)를 구현하기 위한 도커 데몬(Docker daemon)입니다.

   이를 통해 Kubernetes는 다양한 컨테이너 런타임을 지원하고, 컨테이너의 생성, 시작, 종료, 모니터링 등을 통일된 방식으로 관리할 수 있습니다.

  `cri-dockerd`를 사용하면 Kubernetes 클러스터에서 기존에 사용하던 도커와 동일한 방식으로 컨테이너를 관리할 수 있으면서, 다른 CRI를 구현한 컨테이너 런타임으로 전환하는 것도 가능합니다. 이는 Kubernetes가 여러 컨테이너 런타임을 지원하고 확장성을 갖추는 데 도움을 주는 중요한 요소입니다.

  

- **docker에 대해서 간단히 설명해주세요.**

  컨테이너화 기술을 제공하는 오픈 소스 플랫폼으로, 애플리케이션을 컨테이너라는 단위로 패키징하고 배포하는 것을 도와줍니다. 

  컨테이너는 격리된 환경에서 애플리케이션과 그에 필요한 라이브러리, 설정 등을 함께 묶어 실행할 수 있는 가볍고 이식성이 높은 단위입니다.

  1. 도커 엔진 (Docker Engine): 컨테이너를 생성, 실행, 관리하는 핵심 엔진입니다. 컨테이너 런타임과 이미지 빌더 등의 기능을 포함하고 있습니다.
  2. 도커 이미지 (Docker Image): 컨테이너를 실행하기 위한 실행 가능한 패키지입니다. 애플리케이션과 필요한 모든 설정, 라이브러리 등이 이미지로 패키징되어 있습니다.
  3. 도커 컨테이너 (Docker Container): 도커 이미지를 기반으로 실행되는 실행 단위입니다. 격리된 환경에서 애플리케이션이 실행되며, 호스트와 독립적으로 동작합니다.
  4. 도커 레지스트리 (Docker Registry): 도커 이미지를 저장하고 공유하기 위한 저장소입니다. 도커 허브(Docker Hub)는 가장 잘 알려진 도커 레지스트리 중 하나입니다.

  

- **kubernetes에 대해서 간단하세 설명해주세요**

   컨테이너 오케스트레이션(Orchestration) 시스템으로, 여러 대의 서버에 분산되어 실행되는 컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화하는 오픈 소스 플랫폼입니다.

  1. 컨테이너 오케스트레이션: 쿠버네티스는 여러 개의 컨테이너를 노드(서버)들에 자동으로 분산 배포하고, 컨테이너 간의 통신, 확장, 관리를 자동으로 처리합니다.
  2. 자동화: 쿠버네티스는 노드의 상태를 감지하고 필요에 따라 컨테이너를 자동으로 스케일링하고 장애 복구를 수행합니다.
  3. 서비스 디스커버리: 쿠버네티스는 애플리케이션의 서비스들을 동적으로 발견하고 서로 통신할 수 있도록 지원합니다.
  4. 롤링 업데이트: 쿠버네티스는 애플리케이션을 중단시키지 않고 롤링 업데이트를 수행하여 애플리케이션을 무중단으로 업데이트할 수 있습니다.
  5. 확장성: 쿠버네티스는 수천 개의 노드와 수백만 개의 컨테이너를 다룰 수 있는 높은 확장성을 가지고 있습니다.
  6. 포팅 가능성: 쿠버네티스는 다양한 클라우드 프로바이더나 온프레미스 환경에 쉽게 배포할 수 있으며, 다양한 컨테이너 런타임을 지원합니다.
  7. 선언적 구성: 쿠버네티스는 YAML 파일 등으로 애플리케이션의 구성을 선언적으로 정의하여 관리할 수 있습니다.

- **Kubernetes의 Master Node와 Worker Node에 대해서 각각 개념과 차이점에 대해서 설명해주세요.**

  - Master Node:

    Master Node는 쿠버네티스 클러스터의 제어 플레인을 담당하며, 클러스터의 전반적인 관리와 제어를 담당합니다.

    - Master Node는 쿠버네티스 클러스터의 제어 플레인(Control Plane)을 담당하는 노드입니다.
    - API 서버, 스케줄러(Scheduler), 컨트롤러 매니저(Controller Manager), etcd 데이터베이스가 포함됩니다.

  - Worker Node:

    Worker Node는 실제 컨테이너가 실행되는 노드로, 파드들이 배포되고 실행되는 곳입니다. 컨테이너들의 실행과 상태 보고를 담당합니다.

    - Worker Node는 실제로 컨테이너가 실행되는 호스트 머신입니다.
    - 컨테이너 런타임(Docker, containerd 등), kubelet, kube-proxy 등의 구성 요소가 포함됩니다.
    - 컨테이너 런타임은 컨테이너를 실행하고 관리하는 역할을 합니다.
    - kubelet은 Master Node와 통신하여 할당된 파드를 실행하고 노드의 상태를 보고하는 역할을 합니다.
    - kube-proxy는 파드 간의 네트워크 통신을 관리하는 역할을 합니다.

  

- **cluster에 대해서 설명해주세요**

  클러스터(Cluster)는 여러 대의 컴퓨터 또는 서버가 네트워크로 연결되어 하나의 시스템으로 동작하는 컴퓨터 시스템의 집합을 의미합니다. 클러스터는 다수의 노드(Node)가 함께 작동하여 고성능 및 고가용성을 제공하고, 일부 노드의 장애에도 전체 시스템이 동작할 수 있는 내결함성을 가집니다.

  

- **pod에 대해서 설명해주세요. docker container와의 차이점도 설명해주세요.**

  파드(Pod)는 쿠버네티스(Kubernetes)에서 가장 작은 배포 단위이며, 하나 이상의 컨테이너를 포함하는 쿠버네티스 오브젝트입니다.

  1. 독립성: 각 파드는 고유한 IP 주소와 호스트명을 가지며, 자체적으로 컨테이너를 실행하고 관리합니다.
  2. 공유 네트워크와 스토리지: 파드 안의 컨테이너는 동일한 네트워크 네임스페이스와 스토리지 볼륨을 공유합니다. 따라서 컨테이너들은 서로 통신하거나 데이터를 공유하는 데 용이합니다.
  3. 단일 로그 및 이벤트: 파드 안의 모든 컨테이너들은 동일한 로그와 이벤트를 공유합니다.

  > Docker 컨테이너는 단일 컨테이너를 실행하기 위해 사용되는 단위로, 단일 프로세스를 실행하거나 애플리케이션의 일부를 담당합니다. 반면 쿠버네티스 파드는 다중 컨테이너를 함께 묶어서 하나의 논리적인 단위로 실행하고, 컨테이너들 사이에 네트워크와 스토리지를 공유할 수 있습니다.

  

- **kubernetest의 namespace에 대해서 설명해주세요**

  쿠버네티스 클러스터 내에서 리소스를 그룹화하는 가상의 공간입니다. 네임스페이스를 사용하여 리소스를 논리적으로 분리하고 충돌을 방지할 수 있습니다. 

  

- **kubernetest의  service에 대해서 설명해주세요**

  파드는 동적으로 생성되고 삭제될 수 있으며, 각 파드는 고유한 IP 주소를 가지지만 이 IP 주소는 파드가 삭제되거나 재시작될 때마다 변경될 수 있습니다. 서비스는 이러한 파드들의 앞단에 위치하여 고정된 IP 주소와 DNS 이름을 제공하여 클라이언트가 파드에 접근하고, 파드들 간에 통신할 수 있도록 합니다.

  

- **kubernetest의  load balanser에 대해서 설명해주세요**

  쿠버네티스의 로드 밸런서는 서비스를 외부에 노출하기 위한 매커니즘으로 사용됩니다. 서비스를 로드 밸런서 유형으로 설정하면, 클러스터 외부에서 서비스에 접근할 수 있도록 외부 IP 주소를 할당합니다.

  

- **kubernetest의  Persistent Volume  Claim(PVC)에 대해서 설명해주세요**

  쿠버네티스의 Persistent Volume Claim(PVC)은 영구적인 스토리지 볼륨을 동적으로 할당하기 위한 요청을 나타내는 리소스입니다. PVC를 사용하여 파드가 지속적으로 유지되지 않고 삭제되어도 데이터가 보존되도록 스토리지를 동적으로 할당할 수 있습니다

  

- **kubernetest의  secret에 대해서 설명해주세요**

  쿠버네티스의 시크릿(Secret)은 암호화된 데이터를 저장하는 데 사용되는 리소스입니다. 주로 패스워드, 토큰, 인증서 등의 민감한 정보를 저장하는 데 사용됩니다. 시크릿은 Base64로 인코딩되어 저장되기 때문에 보안적으로 안전하게 저장됩니다. 

  

- **kubernetest의 Taints와 Tolerations에 대해서 설명해주세요**

  쿠버네티스의 Taints와 Tolerations은 노드와 파드 간의 관계를 조정하는 메커니즘입니다. 

  - Taints는 특정 노드에 특정 조건을 설정하여 파드가 해당 노드에 스케줄링되지 않도록 하는 것을 의미합니다. 
  - Tolerations는 파드가 특정 노드에 스케줄링될 때 해당 노드의 Taints를 허용하는 것을 의미합니다. 

  이를 통해 특정 노드에 파드를 할당하여, 파드와 노드 간의 특별한 제약 조건을 지정할 수 있습니다. 이는 특정 노드에만 특정 파드를 배치하거나, 노드에 대한 특정 설정을 적용하고자 할 때 유용하게 사용됩니다.

  

- **Kubernetes 클러스터 모니터링 방법에 대해서 설명해주세요**

  클러스터 모니터링은 클러스터 내의 리소스 사용, 상태, 성능 등을 지속적으로 감시하고 분석하여 클러스터의 안정성과 가용성을 유지하는 중요한 작업입니다. 클러스터 모니터링을 통해 리소스 사용량, 애플리케이션 성능, 노드 상태 등을 파악하여 이슈를 조기에 감지하고 대응할 수 있습니다. 

  - Kubernetes 모니터링

    Kubernetes에서 제공하는 모니터링 기능은 클러스터 내부의 다양한 리소스를 추적하고 상태를 확인하는 기능을 포함합니다. 

  - Prometheus 모니터링

    Prometheus는 CNCF(Cloud Native Computing Foundation)에 의해 개발되고 유지되는 오픈 소스 모니터링 시스템입니다. Prometheus는 다양한 서비스 및 시스템에서 메트릭을 수집하고 쿼리하고 시각화하는 데 사용됩니다. 

  

- **클라우드에서 K8s를 운영할때 어떤 이점을 가질 수 있는지 설명해주세요**

  1. **스케일링과 자동화:**
     - 클라우드에서 K8s를 운영하면 필요에 따라 리소스를 신속하게 확장하거나 축소하여 애플리케이션의 성능과 가용성을 최적화할 수 있습니다. 또한 클라우드 제공자의 자동화 기능을 통해 클러스터 관리 작업을 자동화할 수 있습니다.
  2. **유연성과 탄력성:**
     - 클라우드 환경에서 K8s를 운영하면 필요에 따라 리소스를 쉽게 조정할 수 있어 애플리케이션의 요구사항에 유연하게 대응할 수 있습니다. 이는 비즈니스의 변화에 더 빠르게 대응할 수 있음을 의미합니다.
  3. **높은 가용성과 안정성:**
     - 클라우드 서비스 제공자는 여러 데이터 센터에 걸쳐 복제된 서버를 제공하여 높은 가용성과 안정성을 보장합니다. 이를 통해 애플리케이션의 장애 복구 및 이중화를 지원합니다.
  4. **관리의 용이성:**
     - 클라우드 제공자는 K8s 클러스터의 배포, 업그레이드, 모니터링, 로깅 등의 관리를 담당하여 기업은 서비스에 집중할 수 있습니다.