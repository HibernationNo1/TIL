# NAS

NAS(Network attached storage): 네트워크 결합 스토리지 라는 뜻으로, 인터넷 또는 랜선을 이용한 내부망으로 연결된 외장 스토리지를 의미한다.

컴퓨터에 직접 연결하지 않고 네트워크를 통해 데이터를 주소 받는 저장장치인 것이다.



### NAS에 대해서



NAS는 크게 소프트웨어적 NAS와 하드웨어적 NAS로 나뉜다.

#### 소프트웨어적 NAS

일반 서버나 컴퓨터에 NAS 소프트웨어를 설치하여 NAS 기능을 제공하는 방식이다.

- TrueNAS

  2005년부터 FreeNAS라는 이름으로 시작된 오픈 소스 NAS 프로젝트로, 지금은 TrueNAS라고 명칭이 바뀌었다.

   x86_64 아키텍처를 사용하는 하드웨어라면 설치가 가능하며, 설치 방법은 ubuntu처럼 usb를 구성하여 진행한다.

  TrueNAS_Dashboard 001.png 그림 삽입

- UnRAID

   Lime Technology에서 개발한 네트워크 연결 스토리지(NAS) 운영 체제로, 유료 서비스이다.

  기존의 RAID 배열과 달리, 디스크를 독립적으로 관리하면서 유연성과 성능을 제공하기 때문에 아래의 특징을 가질 수 있다.

  - 다양한 크기와 종류의 디스크(HDD, SSD)를 혼합하여 사용할 수 있다.
  - 각 디스크는 독립적으로 관리하기 때문에 NAS를 구성하고 Widnows 환경을 계속 사용할 수 있다.

  가정용 또는 소규모 비즈니스 환경에서 데이터 저장, 백업, 미디어 서버, 가상화 호스트 등으로 사용된다.

**단점**: 스토리지 풀 생성, 접근 제어, NFS설정, 도커 등 하나부터 열까지 전부 설정해야 사용할 수 있다.



#### 하드웨어적 NAS

NAS 기능을 제공하기 위해 특별히 설계된 물리적 장치로, 전용 하드웨어와 소프트웨어를 통합하여 사용된다.

하드웨어적 NAS는 bay를 기준으로 하여 용도별로 나눌 수 있다.

> bay란?
>
> 하드디스크를 몇 개 장착할 수 있는지를 나타내는 단위. 1 bay면 하드디스크 1개를 장착할 수 있다는 것을 의미한다.

- 가정용 NAS

  1~2베이로 구성되는 NAS로, 저 성능의 CPU와 낮은 memory용량을 가지며 10만원~100만원 사이의 가격의 다양한 제품이 있다.

- SOHO(Small Office/Home Office) NAS

  소규모 비즈니스, 자영업자, 프리랜서 등이 운영하는 작은 규모의 작업 환경을 위한 NAS로, 2~4개의 베이로 구성된 제품이 많다.

- 기업용 NAS

  고성능의 CPU와 고용량의 memory를 가지고 있고, 보통 6베이 이상으로 구성되어 있다.



#### 요약

| 특징      | 하드웨어적 NAS            | 소프트웨어적 NAS            |
| --------- | ------------------------- | --------------------------- |
| 성능      | 최적화된 성능             | 하드웨어에 따라 다름        |
| 비용      | 초기 비용 높음            | 기존 하드웨어 사용 가능     |
| 유연성    | 제한된 유연성             | 높은 유연성                 |
| 설치/설정 | 간단한 설치 및 설정       | 설치 및 설정 복잡할 수 있음 |
| 확장성    | 물리적 제한 존재          | 하드웨어 업그레이드 가능    |
| 지원      | 제조업체의 기술 지원 제공 | 커뮤니티 또는 유료 지원     |



**Synology란 무엇인가?**

시놀로지(Synology)는 네트워크 스토리지 솔루션(NAS, Network Attached Storage)을 개발하고 제조하는 대만 기반의 회사이다.

NAS를 제조하고 판매하는 기업은 수도없이 많지만, Synology의 점유율이 47%를 차지할 만큼 앞도적으로 많다.



### 보안 지식

#### RAID란? 

여러 개의 물리적 하드 드라이브를 하나의 논리적 유닛으로 결합하여 데이터의 중복성, 성능 및 신뢰성을 향상시키는 기술

- **RAID 0 (스트라이핑)**: 데이터를 여러 디스크에 분할하여 저장하는 방식
- **RAID 1 (미러링)**: 동일한 데이터를 두 개 이상의 디스크에 복제하여 저장하는 방식
- **RAID 5 (패리티)**: 데이터를 블록 단위로 분할하고, 패리티 정보를 추가하여 저장하는 방식
- **RAID 6 (이중 패리티)**: RAID 5와 유사하지만, 두 개의 패리티 블록을 사용한다.

##### RAID 6  예시

- **모든 데이터는 0과 1로 이루어져 있다.**

  데이터 A: **`1101101010010110`**

  데이터 B: **`1010101111001101`**

  데이터 C: **`1110010101010111`**

  데이터 D: **`1001110010101001`**

- **위와 같은 데이터가 있을 때, 데이터를 4개의 데이터 블록으로 나누면**
  A1, A2, A3, A4는 1101, 1010, 1001, 0110 과 같으며, 다른 B, C, D도 동일하게 적용한다.

- **이 때  아래와 같은 규칙에 의해 패리티 데이터가 구성된다.**

  **패리티 블록 1**  P1 = A1 ⊕ B2 ⊕ C3 ⊕ D4  

  **패리티 블록 2**  Q1 =  (A1 ⊕ B2) ⊕ (C3 ⊕ D4)    # 간단히 예를 든 것. 

  > - ⊕는 XOR를 의미
  > - 예시를 위해 쉽게 표현한것이지만 실제로 블록 Q는 Reed-Solomon 코드를 사용하여 더욱 복잡한 과정을 통해 생성된다.

  위와 같을 때, 각 패리티 블록은 아래와 같이 계산된다.

  - **P1** = `A1 ⊕ B2 ⊕ C3 ⊕ D4` = `1101 ⊕ 1011 ⊕ 0101 ⊕ 1001` = 1010
  - **P2** = `A2 ⊕ B3 ⊕ C4 ⊕ D1` = `1010 ⊕ 1100 ⊕ 0111 ⊕ 1001` = 1000
  - **P3** = `A3 ⊕ B4 ⊕ C1 ⊕ D2` = `1001 ⊕ 1101 ⊕ 1110 ⊕ 1100` = 0110
  - **P4** = `A4 ⊕ B1 ⊕ C2 ⊕ D3` = `0110 ⊕ 1010 ⊕ 0101 ⊕ 1010` = 0011
  - **Q1** = `(A1 ⊕ B2) ⊕ (C3 ⊕ D4)` = `(1101 ⊕ 1011) ⊕ (0101 ⊕ 1001)` = 1110
  - **Q2** = `(A2 ⊕ B3) ⊕ (C4 ⊕ D1)` = `(1010 ⊕ 1100) ⊕ (0111 ⊕ 1001)` = 1000
  - **Q3** = `(A3 ⊕ B4) ⊕ (C1 ⊕ D2)` = `(1001 ⊕ 1101) ⊕ (1110 ⊕ 1100)` = 0110
  - **Q4** = `(A4 ⊕ B1) ⊕ (C2 ⊕ D3)` = `(0110 ⊕ 1010) ⊕ (0101 ⊕ 1010)` = 0011

- 디스크 구조는 아래와 같다

  ```
  디스크 1: A1 | B1 | C1 | D1 | P1 | Q1	==	1101 | 1010 | 1110 | 1001 | 1000 | 0000 
  디스크 2: A2 | B2 | C2 | D2 | P2 | Q2	==	1010 | 1011 | 0101 | 1100 | 1000 | 1000 
  디스크 3: A3 | B3 | C3 | D3 | P3 | Q3	==	1001 | 1100 | 0101 | 1010 | 1010 | 1010  
  디스크 4: A4 | B4 | C4 | D4 | P4 | Q4	==	0110 | 1101 | 0111 | 1001 | 0001 | 0101 
  디스크 5: P1 | P2 | P3 | P4 | D1 | D2	==	1000 | 1000 | 1010 | 0001 | 1001 | 1100 
  디스크 6: Q1 | Q2 | Q3 | Q4 | D3 | D4	==	0000 | 1000 | 1010 | 0101 | 1010 | 1001
  ```

**디스크 1을 잃었을 때**

- **A1 복구**

  A1 = `P1 ⊕ B2 ⊕ C3 ⊕ D4` = `1010 ⊕ 1011 ⊕ 0101 ⊕ 1001 ` = 1101

  - P1 = 1010 (디스크 5)
  - B2 = 1011 (디스크 2)
  - C3 = 0101 (디스크 3)
  - D4 = 1001 (디스크 4)

- **B1 복구**

  B1 = `P2 ⊕ A2 ⊕ C4 ⊕ D1` = `1000 ⊕ 1010 ⊕ 0111 ⊕ 1001` = 1010

  - P2 = 1000 (디스크 5)
  - A2 = 1010 (디스크 2)
  - C4 = 0111 (디스크 4)
  - D1 = 1001 (디스크 5)

- **C1 복구**

  C1 = `P3 ⊕ A3 ⊕ B4 ⊕ D2` = `0110 ⊕ 1001 ⊕ 1101 ⊕ 1100` = 1110

  - P3 = 0110 (디스크 5)
  - A3 = 1001 (디스크 3)
  - B4 = 1101 (디스크 4)
  - D2 = 1100 (디스크 3)

- **D1 복구**

  D1 = `P4 ⊕ A4 ⊕ B1 ⊕ C2` = `0011 ⊕ 0110 ⊕ 1010 ⊕ 0101` = 1001

  - P4 = 0011 (디스크 5)
  - A4 = 0110 (디스크 4)
  - B1 = 1010 (디스크 2)
  - C2 = 0101 (디스크 2)

### RS3617xs+

우리가 사용하고 있는 NAS의 model명은 `RS3617xs+`이다.

**특징**

- 기본 12베이를 제공하며, Synology 사의 확장 유닛 디바이스를 사용하면 최대 36개의 베이로 확장이 가능하다.
- 최대 128 GB의 RAM을 지원하는 시스템 보드(4개의 슬롯, 각 슬롯에 32GB 설치 가능)
- 다양한 RAID 구성 옵션 지원 (RAID 0, 1, 5, 6, 10 등)

- ECC 메모리로 데이터 무결성 보장

  > ECC 메모리란?
  >
  > 메모리는 데이터 무결성을 유지하기 위해 설계된 메모리 유형으로, 일반적인 RAM은 데이터 전송 중에 발생할 수 있는 비트 오류를 감지하지 못하는 반면, ECC 메모리는 이러한 오류를 감지하고 수정할 수 있다.

  NAS의 ECC메모리 확인

  ```
  Error Correction Type: Multi-bit ECC
  
  Total Width: 72 bits
  Data Width: 64 bits
  ```

  Total Width가 72 비트이고 Data Width가 64 비트인 경우, 나머지 8 비트는 ECC를 위한 것임을 알 수 있다.

  > 어떻게 무결성을 보장하는가? 
  >
  > 데이터를 메모리에 저장할 때, ECC 메모리는 각 메모리 단어(예: 64비트)에 대해 패리티 비트를 생성한다. 패리티 비트는 원래 데이터 비트를 기반으로 계산되며, 이를 통해 데이터의 상태를 나타낸다.
  >
  > 1. 데이터 저장 시 
  >
  >     64비트 데이터 단어에 대해 8개의 패리티 비트를 추가하여 72비트의 ECC 메모리 단어를 생성한다.
  >
  >    1. 데이터 비트 
  >
  >       ```
  >       d1 d2 d3 d4 d5 ... d62 d63 d64
  >       ```
  >
  >    2. 패리티 비트
  >
  >       ```
  >       p1 p2 p3 p4 p5 p6 p7 p8
  >       ```
  >
  >       패리티 비트를 계산하는 방법은 알고리즘에 따라 다양하지만, 일반적으로 해밍 코드(Hamming Code)를 사용한다.
  >
  >       **해밍 코드란?**
  >
  >       수학자 리처드 웨슬리 해밍(Richard Wesley Hamming)이 개발한 코드로, 컴퓨터 스스로가 수신 데이터의 오류를 검출 및 수정이 가능한 코드이다.
  >
  >       - 해밍 코드는 어떻게 만드는가?
  >
  >         n개의 데이터 비트로 이루어진 비트열에 k개의 패리티 비트를 더해서 n + k개의 비트를 갖는 새로운 비트열(CodeWord)를 생성하면 된다.
  >
  >         이 때 k의 기준은 아래의 식을 따른다
  >
  >         hamming_code_1 그림 삽입
  >         $$
  >         2^k -1  \geq n + k
  >         $$
  >
  >       - 패리티 비트는 데이터 비트 사이에 어떻게 삽입되는가?
  >
  >         2^n 의 위치에 존재한다.
  >
  >         즉, (P1, P2, P3, ..., Pn) : (1번째, 2번째, 4번째, ...., 2^(n-1)번째)
  >
  >       - 패리티 비트는 어떻게 계산되는가?
  >
  >         - p1은 위치 **1**`(2^0 = 1)`부터 시작하여 **2**`(2^1 = 2)`비트마다 **1**`(2^0 = 1)`개의 비트를 제외하여 계산 (커버하는 위치: 1, 3, 5, 7, 9, 11, ...)
  >
  >           `p1` = `d1 XOR d3 XOR d5 XOR d7 XOR d9 XOR ... `
  >
  >           **1**, `2`, **3**, `4`, **5**, `6`, **7**, ...
  >
  >         - p2은 위치 **2**`(2^1 = 2)`부터 시작하여 **4**`(2^2 = 4)`비트마다 **2**`(2^1 = 2)`개의 비트를 제외하여 계산 (커버하는 위치: 2, 3, 6, 7, 10, 11, ...)
  >
  >           `p2` = `d2 XOR d3 XOR d6 XOR d7 XOR d10 XOR ... `
  >
  >           **2**, **3**, `4`, `5`, **6**, **7**, `8`, `9`,  **10**, **11**, `12`, `13`,  **14**, ...
  >
  >         - p3은 위치 **4**`(2^2 = 4)`부터 시작하여 **8**`(2^3 = 8)`비트마다 **4**`(2^2 = 4)`개의 비트를 제외하여 계산 (커버하는 위치: 4, 5, 6, 7, 13, 14, ...)
  >
  >           `p3` = `d4 XOR d5 XOR d6 XOR d7 XOR d12 XOR ... `
  >
  >           **4**, **5**, **6**, **7**, `8`, `9`, `10`, `11`,  **12**, **13**, **14**, **15**, `16`, `17`, `18`, `19`, **20**, **21**, **22**, **23**, `24`, .. 
  >
  > 2. 데이터 읽기 시
  >
  >    읽은 데이터와 패리티 비트를 비교하여 데이터에 오류가 있는지 확인한다.
  >
  >    오류 발생 시 오류가 발생한 위치를 계산하고 해당 비트를 수정한다.
  >
  > **예시**
  >
  > `0110101111010011`라는 16비트 데이트에 대한 패리티 비트 개수는 아래와 같다.
  > $$
  > 2^5 \geq 17 + 5
  > $$
  > 가 성립되므로 패리티비트는 5개, 위치는 (1, 2, 4, 8, 16), Hamming Code는 아래와 같다
  >
  > - **P1** (위치 1): 1, 3, 5, 7, 9, 11, 13, 15
  >
  >   비트 값: `0 1 1 1 1 0 0 1`
  >
  >   계산: 0 ⊕ 1 ⊕ 1 ⊕ 1 ⊕ 1 ⊕ 0 ⊕ 0 ⊕ 1  = 1
  >
  > - **P2** (위치 2): 2, 3, 6, 7, 10, 11, 14, 15
  >
  >   비트 값: `1 1 0 1 1 0 0 1 `
  >
  >   계산: 1 ⊕ 1 ⊕ 0 ⊕ 1 ⊕ 1 ⊕ 0 ⊕ 0 ⊕ 1  = 1
  >
  > - **P3** (위치 4): 4, 5, 6, 7, 12, 13, 14, 15
  >
  >   비트 값: `0 1 0 1 1 0 0 1`
  >
  >   계산: 0 ⊕ 1 ⊕ 0 ⊕ 1 ⊕ 1 ⊕ 0 ⊕ 0 ⊕ 1  = 0
  >
  > - **P4** (위치 8): 8, 9, 10, 11, 12, 13, 14, 15
  >
  >   비트 값: `1 1 1 0 1 0 0 1 `
  >
  >   계산: 1 ⊕ 1 ⊕ 1 ⊕ 0 ⊕ 1 ⊕ 0 ⊕ 0 ⊕ 1  = 1
  >
  > - **P5** (위치 16): 16
  >
  >   비트 값: `1`
  >
  >   계산: 1
  >
  > 패리티 비트: `11011`
  >
  > 패리티비트까지 포함된 해밍 코드는 `110011011011110110011`가 된다.
  >
  > 원본 데이터 중 7번째(D7) 비트가 1에서 0으로 임의로 변경(손상)된 경우
  >
  > `011010`0`111010011`
  >
  > 패리티 코드가 변경된다.
  >
  > - **P1** (위치 1): 1, 3, 5, 7, 9, 11, 13, 15
  >
  >   비트 값: `0 1 1 0 1 0 0 1 `
  >
  >   계산: 0 ⊕ 1 ⊕ 1 ⊕ 0 ⊕ 1 ⊕ 0 ⊕ 0 ⊕ 1  = 0
  >
  > - **P2** (위치 2): 2, 3, 6, 7, 10, 11, 14, 15
  >
  >   비트 값: `1 1 0 0 1 0 0 1 `
  >
  >   계산: 1 ⊕ 1 ⊕ 0 ⊕ 0 ⊕ 1 ⊕ 0 ⊕ 0 ⊕ 1  = 0
  >
  > - **P3** (위치 4): 4, 5, 6, 7, 12, 13, 14, 15
  >
  >   비트 값: `0 1 0 0 1 0 0 1`
  >
  >   계산: 0 ⊕ 1 ⊕ 0 ⊕ 0 ⊕ 1 ⊕ 0 ⊕ 0 ⊕ 1  = 1
  >
  > - **P4** (위치 8): 8, 9, 10, 11, 12, 13, 14, 15
  >
  >   비트 값: `1 1 1 0 1 0 0 1  `
  >
  >   계산: 1 ⊕ 1 ⊕ 1 ⊕ 0 ⊕ 1 ⊕ 0 ⊕ 0 ⊕ 1  = 1
  >
  > - **P5** (위치 16): 16
  >
  >   비트 값: `1`
  >
  >   계산: 1
  >
  > 손상된 데이터의 패리티 비트: `00111`
  >
  > 이를 통해 기존의 패리티 비트 `11011`와 비교하여 아래의 계산을 수행하여 오류 비트 위치를 추적 할 수 있다.
  >
  > ```
  > 00111 (손상된 패리티 비트)
  > 11011 (원래 패리티 비트)
  > ------  XOR 계산
  > 11100  -->  10진수로 변경: 1 + 2 + 4 = 7
  > ```
  >
  > 7번째 오류.

  

- AES-NI 하드웨어 암호화 엔진으로 데이터 보호

  > AES-NI란?
  >
  > 인텔이 개발한 명령어 세트로, 프로세서가 고속으로 데이터 암호화를 수행할 수 있도록 설계되어 있다.
  >
  > 이는 CPU내부의 하드웨어 수준에서 암호화 연산 이루어지는 것으로, 소프트웨어 기반 암호화보다 훨씬 빠른 성능을 제공한다.
  >
  > - 데이터 전송 속도를 유지하면서도 높은 보안을 유지할 수 있다.
  > - 하드웨어 가속을 통해 암호화 연산이 CPU에 큰 부담을 주지 않으므로, 시스템 성능에 미치는 영향을 최소화한다.

**서버 재원**

| 재원 종류     |                           |
| ------------- | ------------------------- |
| CPU           | INTEL Xeon D-1531(6 core) |
| 물리적 메모리 | 32GB (16 * 2)             |
| HDD           | **10.9 TB** * 12          |





#### NAS사용법

##### Disk검사

disk의 상태가 정상인지, 사용이 가능한지 확인하는 과정

**저장소 관리자 > HDD/SSD > 상태 정보 > S.M.A.R.T. **

- S.M.A.R.T.(Self-Monitoring, Analysis, and Reporting Technology): 하드 드라이브와 SSD에서 디스크의 상태를 모니터링하고 잠재적인 실패를 예측하기 위한 기술

Disk검사 이미지 삽입



##### 알림

시스템 상태가 변경되거나 오류가 있을 때 SMS을 통해 알림 메시지를 받을 수 있다.

**제어판 > 시스템/알림 > SMS**

alt 이미지 삽입

용량 부족 알림의 한계용량 설정은 `저장소 관리자 > 저장소 > 볼륨의 설정 > 용량부족 알림`에서 설정 가능

alt_설정 이미지 삽입



##### File Station log

누가, 어떤 파일을 어떻게 했는지 로그를 확인할 수 있다.
**File Station > 설정 > File Station 로그 활성화, 로그 보기**

파일 로그 이미지 삽입

로그 활성화 옵션을 꺼버리면 로그가 사라지니, 절대 끄지 말것.





##### Snapshot Replication

파일의 특정 시점의 상태를 기록하는 기능으로, 파일이 변경 또는 손상되었을 경우 이전 기록해 두었던 시점으로 복구할 수 있도록 한다.

스냅샷이 생성될 때 새로운 데이터가 기록되는 것이 아니라, 원본 데이터가 변경될 경우 변경된 블록을 저장한다. (스냅샷의 용량 소모는 데이터 변경 빈도와 크기에 따라 달라진다.)

1. 스냅샷 저장

   **Snapshot Replication > 스냅샷 > 기록할 폴더 선택**

   - `스냅샷 > 스냅샷 촬영`: 현재를 기준으로 기록

   - `설정 > 스케줄 > 스냅샷 예약 활성화`:  특정 시간마다 기록하도록 스케줄링

     스케줄링을 할 때는 각 폴더마나 예약 시간을 10분 띄워서 하도록 하자.

   - `설정 > 보존 > 보존정책 활성화`: 원하는 스냅샷만 유지하고 나머진 삭제하여 저장소 공간 확보

2. 데이터 복구

   **Snapshot Replication > 복구 > 스냅샷 리스트 중 복구하고자 하는 시점 선택 > 작업 > 이 스냅샷으로 복원 > 공유 폴더의 설정 복원 체크**

스냅샷 그림 삽입



##### VPN Server

NAS에서 VPN server를 구성하여 활성화 할 수 있다.(패키지센터에서 설치 가능)

VPN server를 구성하면 아래의 이점이 있다.

- 보안 강화

  - VPN은 암호화된 터널을 통해 데이터를 전송하기 때문에, NAS와 클라이언트 간의 데이터 전송이 안전하게 이루어진다.
  - NAS에 접속할 때 NAS에 설정된 VPN서버의 IP 주소를 통해 접속하게 된다. 외부에서는 VPN 서버의 IP 주소만 볼 수 있고, NAS의 내부 IP 주소는 노출되지 않는다.

- 통합 관리

  NAS가 소속된 내부 네트워크에 안전하게 접속할 수 있다.

  - VPN GATEWAY처럼, 인증되지 않은 사용자는 NAS에서 전부 차단한다.

  vpn_1 그림 삽입

  또는 스위치 역할도 할 수 있는 모델도 있다.

  vpn_2 그림 삽입



##### 지원 센터

NAS의 사용법이나, 어떠한 문제가 생겼을 때 조치 방법을 문의하려면 synology 공식 지원센터에 문의하여 도움을 받을 수 있다.

**제어판 > 지원 센터**

지원센터_1, 지원센터\_2 그림 삽입

Web page를 통해 문의를 넣는것이 더욱 편리함 [Synology Account](https://account.synology.com/en-global/support)

> AI연구소 google 계정으로 가입을 해 놓았음.



### 드라이브 교체

#### RAID 6을 사용 중인 경우

**사전 준비**

1. 드라이브 상태를 확인하고 교체가 필요한지 확인 (아래 링크를 참조)

   https://kb.synology.com/DSM/tutorial/How_to_diagnose_drives_health_status_when_receiving_bad_sector_warning

2. `저장소 관리자 > 저장소 > 볼륨 선택 > 전역 설정 > 자동 복구` 설정 체크

   문제가 발생한 드라이브를 슬록에서 제거하고 새 드라이브로 교체하면 자동으로 스토리지 풀을 복구한다.

   - 자동 목구 기능이 활성화되면 새로 설치된 드라이브가 자동으로 결함 있는 드라이브를 교체한다. 
   - 새로 설치된 드라이브의 모든 데이터가 지워진다.
   - 스토리지 풀이 Hot Spare 드라이브로 보호되면 시스템은 우선적으로 이러한 드라이브를 사용하여 저하된 스토리지 풀을 복구한다.

3. 현재 저장된 데이터 용량이 교체하고자 하는 드라이브를 제거해도 사용 가능한 용량 범위인지 확인한다.

   단, 이미 교체하고자 하는 드라이브가 수명을 다 했다면 사용 가능한 용량에서 오버된 용량만큼의 데이터는 복구가 불가능하다.

   [RAID 계산기](https://www.synology.com/ko-kr/support/RAID_calculator?drives=12%20TB%7C12%20TB%7C12%20TB%7C12%20TB%7C12%20TB%7C12%20TB%7C12%20TB%7C12%20TB%7C12%20TB%7C12%20TB%7C12%20TB%7C12%20TB)

   RAID계산 그림 삽입

4. [Synology 제품 호환 목록][https://www.synology.com/compatibility]에서 교체할 드라이브가 호환되는지 확인.

   호환제품검색 그림 삽입

5. `저장소 관리자 > HDD/SSD > 교체할 드라이브 선택 후 상단의 '작업' > 드라이브 비활성화`

   드라이브 비활성화 그림 삽입

**드라이브 교체**

1. 비활성화된 드라이브를 제거하고 새 드라이브를 슬롯에 설치

2. 저장소 관리자 > 교체된 드라이브가 소속된 볼륨 > 드라이브 인식 확인

3. 스토리지 풀 수리가 진행되는지 확인

   드라이브 교체 후 그림 삽입









