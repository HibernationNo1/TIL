# 선형 자료구조

### 순서

1. ##### Array

2. ##### Linked List

3. ##### Doubly Linked List

4. ##### Stack

5. ##### Queue

6. ##### Deque

---



## 1. Array

#### 1. 특징

- 같은 타입의 데이터를 나열한다.

- index로 식별 /조회가 가능하다.

- 연속된 메모리 공간에 순차적으로 저장한다.

- 배열의 크기가 고정이다.

#### 2. 장점

- 논리적 순서와 물리적 순서가 일치하기 때문에 index값을 통한 원소 접근이 용이하고 구현이 쉽다.

- 연속된 메모리 공간에 존재하기 때문에 관리하기 편하다.

#### 3. 단점

- 삽입, 삭제 등과 같은 연산이 비효율적. 

  > 삽입: 삽입한 인덱스를 포함한 그 뒤에 인덱스들에 대한 shift연산을 해줘야 한다.
  >
  > 삭제: 순서를 맞추기 위해 뒤의 원소들을 모두 앞으로 shift연산을 해줘야 함
  >
  > 

- 배열의 크기를 바꿀 수 없다.

- 연속된 메모리라서 중간의 데이터가 삭제되거나 배열 크기보다 작은 index만 사용하면 공간 낭비가 된다.

- 연속적인 메모리 할당이 필요해서 메모리 공간을 많이 사용함

#### 4. 시간 복잡도

- 탐색 연산: O(1)

  > 데이터의 위치를 알고 있기 때문에 검색을 하지않고 바로 접근 할 수 있다.
  >
  > 만약 데이터의 위치를 알고 있지 않다면, array의 index를 하나하나씩 살펴보아야 하며 최악의 경우 데이터의 갯수(n)만큼 찾아야 한다

- 할당: O(1)

  > 데이터를 덮어 씌울 때 또한 데이터의 위치를 알고 있기 때문에 바로 접근이 가능하다

- 삽입 / 삭제

  >- array의 맨 앞을 삽입/삭제: O(1)
  >- array의 맨 뒤에 삽입/삭제: O(1)
  >- array의 중간에 삽입/삭제: O(n) (shift 시간)
  >
  >데이터를 삽입하려 할 때 그 index의 공간을 확보해야 하기 때문에 다른 데이터들의 자리를 하나씩 옮겨야 한다

#### 5. 사용하는 경우

- 데이터 개수가 정해져 있을 때
- 데이터의 삭제와 삽입이 적을 때
- 검색을 해야할 때

> 추후 동적배열에 대한 글 추가 예정

---



## 2. Linked List

#### 1. 특징

- 불연속적 메모리 공간에 저장. 

- 각 원소는 노드(Node) 라고 부른다.

- 노드를 연결하여 형성되어 있다.

  >- 첫번째 노드를 헤드(Head, 머리), 마지막 노드를 테일(Tail, 꼬리)이라고 함.
  >- 각 노드는 데이터와 다음 노드를 가리키는 포인터로 이루어짐.

- 크기가 고정되어 있지 않다.

- index를 바로 참초가 불가능하고 노드들의 순서를 통해 원하는 노드에 도달할 수 있다. 

#### 2. 장점

- 크기가 고정되어 있지 않아 새로운 요소를 추가할 때 크기 제한에서 자유롭다.

- 사용한 메모리 재사용이 가능하고 데이터를 빈 틈 없이 저장한다.

#### 3. 단점

- index 접근이 불가능해 원소를 탐색할 때 Direct Access 불가능(n번 index를 참조하려면 1번부터 n번까지 차례로 접근해야 한다.)
- 포인터로 인해 저장 공간의 낭비가 심하다.
- 탐색할 때 반복자를 이용하여 검색하기 때문에 성능 구림

#### 4. 시간 복잡도

- 탐색 연산: O(n)

  > random으로 주소를 알고 있기 때문에 바로 접근이 불가능하고 head부터 찾기 시작해야 한다. 따라서 원하는 노드가 나올때까지 찾아야 하며 최악의 경우 데이터의 갯수(n)만큼 검색해야 한다.

- 할당: O(n)

  > head에서부터 찾기 시작하며 최악의 경우 데이터의 갯수(n)만큼 검색해야 한다.

- 삽입 / 삭제

  >- list의 맨 앞을 삽입/삭제: O(1)
  >- 배열의 맨 뒤에 삽입/삭제: O(1)
  >
  >head 또는 tail에서 붙이거나 삭제한다면 바로 접근이 가능하다. 따라서 본인의 노드를 head 또는 tail에 연결하면 된다.
  >
  >- 배열의 중간에 삽입/삭제: O(n) (탐색 시간)
  >
  >데이터를 중간에 제거하는 경우 내가 삭제하려는 노드의 위치는 알지만 내 전후의 노드들을 서로 연결시켜줘야 할때 연결하려는 이전 노드를 알지 못하기 때문에 탐색시간이 걸린다.

#### 5. 사용하는 경우

- 크기가 유동적일때
- 삽입과 삭제가 자주 일어날 때
- 검색을 자주 하지 않을 때

---



## 3. Doubly Linked List

#### 1. 특징

- 각 노드가 다음 노드(next)와 이전 노드(previous)를 가리지는 포인터를 가지고 있다.
- Linked List에 비해 메모리를 더 사용하지만 양방향 탐색이 가능하다.



#### 2. 장점

- List 확장이 용이함
- 노드를 탐색하는 방향이 양쪽으로 가능. 즉 높은 index의 값을 찾을 때 역방향으로 탐색이 가능



#### 3. 단점

- 한 노드의 포인터가 잘못됐을 경우 다른 노드에 접근할 수 없게 될 가능성이 있음
- 구현이 Linked List보다 복잡하다.



#### 4. 시간 복잡도

- 탐색 연산: O(n)

- 삽입 / 삭제

  >- list의 맨 앞을 삽입/삭제: O(1)
  >- 배열의 맨 뒤에 삽입/삭제: O(1)
  >- 배열의 중간에 삽입: O(n) 
  >- 배열의 중간에 삭제: O(1) 
  >
  >remove의 경우 데이터의 위치를 모두 알고 있기 때문에 검색없이 바로 제거가 가능하다.



#### 5. 사용하는 경우

- Linked List 보다 대부분 Doubly Linked List를 사용함

---



## 4. Stack

#### 1. 특징

- 한 쪽 끝에서만 자료를 넣고 뺄 수 있는 FILO(First In Last Out) 형태
- 스택에 데이터를 push 하면 항상 top에 들어가고, pop 하면 가장 최근에 푸시한 데이터가 나온다.
- 가장 아래 자료를 Bottom이라고 한다. (bottom의 index는 -1이다.)
- 맨 위 요소만 접근할 수 있음.

#### 2. 장점

- 데이터의 삽입과 삭제가 빠르다
- 구조가 단순하고 구현이 쉽다.

#### 3. 단점

- 크기를 미리 정해놓아야 한다. 사이즈 이상을 push할 때 Overflow발생
- index로 임의 원소 접근이 불가능하다. (접근은 맨 위의 원소만 가능)
- 크기가 불확실할 때, 확장시 확장연산이 오래걸린다.
- 데이터의 put(넣기), pop(빼기)가 한 쪽에서만 가능하다. 

#### 4. 시간 복잡도

- 탐색 연산: O(n)
- 원소를 삽입/삭제하는 경우: O(1)

#### 5. 사용하는 경우

- 재귀 알고리즘
- 역추적을 해야할 때

---



## 5. Queue

#### 1. 특징

- 한 쪽 끝에서만 자료를 넣고 반대쪽에서만 뺄 수 있는 FIFO(First In First Out) 형태
- 데이터가 삽입(push)되는 곳을 front, 제거(pop)되는 곳을 back이라고 한다.

#### 2. 장점

- 데이터의 삽입/삭제가 빠르다.

#### 3. 단점

- queue의 중간에 위치한 데이터로의 접근이 어렵다.
- 데이터를 삭제하는 경우
 - Front는 고정, Back을 이동하면서 데이터를 삭제하는 경우: 데이터를 제거했을 때, 나머지 데이터를 한 칸씩 다 옮겨야 함.
 - 둘 다 이동하면서 삽입, 삭제를 할 경우 : 배열의 끝에 저장되어 있는 상황이면, Back을 더 이상 이동시킬 수 없어서 overflow 발생.

#### 4. 시간 복잡도

- 원소를 삽입/삭제하는 경우: O(1)



#### 5. 사용하는 경우

- 데이터를 입력된 순서대로 처리해야 할 때
- BFS (너비 우선 탐색) 구현할 때

---



## 6. Deque

#### 1. 특징

- queue의 구조에서, 양 쪽 끝에서 자료를 넣는것과 빼는것이 전부 가능
- 연속적인 메모리를 기반으로 하는 '시퀀스 컨테이너'이다. 따라서, 임의 접근 반복자 제공
- 중간 요소가 삽입, 삭제될 때, 요소들을 앞/뒤로 밀 수 있다.

#### 2. 장점

- 데이터의 삽입/삭제가 빠르다.
- 앞, 뒤에서 데이터를 삽입/삭제할 수 있다.
- 크기가 가변적이다. (선언 후에 변경할 수 있다.)
- index로 임의 원소 접근이 가능하다.
- 새로운 원소 삽입 시에, 메모리를 재할당하고 복사하지 않고 새로운 단위의 메모리 블록을 할당하여 삽입한다.

#### 3. 단점

- Dueue의 중간에 위치한 데이터로의 접근이 어렵다.
- 앞/뒤에서의 삽입/삭제 성능은 좋지만 중간에 위치한 데이터 삭제는 효율이 좋지 않다.
- 구현이 어렵다.

#### 4. 시간 복잡도

- 탐색 : O(1) (index 접근)
- 원소를 앞/뒤에 삽입 또는 삭제하는 경우 : O(1)

#### 5. 사용하는 경우

- 앞과 뒤에서 삽입, 삭제가 자주 일어나는 경우
- 데이터의 개수가 가변적일 경우
- 데이터 검색을 거의 하지 않을 경우 (랜덤 요소에 접근해야할 때)

