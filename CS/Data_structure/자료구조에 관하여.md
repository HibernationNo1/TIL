# 자료구조

## 자료구조에 대해서

#### - 선택 기준

- 자료의 처리 시간
- 자료의 크기
- 자료의 활용 빈도
- 자료의 갱신 정도
- 프로그램의 용이성



#### - 특징

##### 1. 효율성 (Efficiency)

자료구조를 사용하는 목적은 효율적인 데이터의 관리 및 사용이다. 

상황에 맞게 적절한 자료구조를 이용하게 되면 실행시간을 단축시켜주거나 메모리 용량의 절약을 이끌어 낼 수 있다.

##### 2. 추상화 (Abstraction)

추상화란 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려내는 것. 

자료구조를 구현할 때 중요한 것은 어느 시점에 데이터를 삽입하고, 어느 시점에서 이 데이터를 어떻게 사용할 것인지에 대해 초점을 맞출 수 있기 때문에 구현 외적인 부분에 더 시간을 쏟고 알고리즘 자체에는 중점을 두지 않는다.

##### 3. 재사용성 (Reusability)

자료구조를 이용하여 데이터를 처리할 경우 해당 자료구조의 인터페이스만 이용하여 데이터를 처리하도록 하므로 모듈화가 가능하다. 

이는 자료구조를 설계할 때 특정 프로그램에 맞추어 설계하지 않고 다양한 프로그램에서 사용될 수 있도록 범용화하여 설계함으로써 가능하다.



#### - 분류

1. **단순 구조**

   - 정수, 실수, 문자, 문자열 등의 기본 자료형

2. **선형 구조** : 자료들 간의 앞뒤 관계가 1:1의 선형관계

   - 배열(Array) : 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료구조
   - 연결 리스트 (Linked List) : 각 노드가 데이터와 포인터를 가지고 한줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조
     - Doubly Linked List : Linked List와 비슷. 각 노드가 앞 뒤의 노드와 연결되어 있는 자료구조 
   - 스택 (Stack) : LIFO (Last In First Out) 나중에 들어온 자료가 먼저 나가는 자료구조
   - 큐 (Queue) : FIFO (First In First Out) 먼저 들어온 자료가 먼저 나가는 자료구조
   - 덱 (Deque) : 양쪽에서 삽입/인출이 가능한 자료구조

3. **비선형 구조** : 자료들 간의 앞뒤 관계가 1:N, N:N의 관계

   - 트리 (Tree) :부모 논드 밑에 여러 자식 노드가 연결되고, 자식 노드가 부모가 되어 다시 각각의 자식 노드가 연결되는 재귀적 형태의 자료구조
   - 그래프 (Graph) : 정점(Vertex)과 정점들을 연결하는 변(Edge)로 구성된 자료구조



## 시간 복잡도

시간복잡도란 알고리즘을 푸는데에 있어서 종료할 떄 까지의 시간과 공간을 얼마나 차지하는지의 표기법이다

시간복잡도를 계산할 시 발생할 수 있는 최악의 연산 수를 **Big-O nation**으로 표시할 수 있다. 계산시 작은 상수들을 제외하고 큰 지수들만 표시한다(데이터의 크기가 커질 수록 상수가 성능의 흐름에 크게 상관없어지고, 알고리즘의 러닝타임을 정확하게 표시한다기 보단 데이터나 사용자의 증가율에 따른 알고리즘의 성능을 예측하는 것이 목표이기 때문이다)

- **O(1) (constant)**

  입력데이터의 크기에 상관없이 언제나 처리속도는 동행하게 이루어진다.

  > ex) sorted Array search

- **O(log n) (logarithmic)**

  입력데이터의 크기가 커지더라도 처리속도가 크게 달라지지 않으며, 실행시간이 지날수록 처리해야 하는 데이터의 양이 절반으로 줄어드며 실행 시간은 증가하지만 속도는 감소한다.

  > ex) Binary search

- **O(n) (linear)**

  입력데이터의 크기에 비례해서 처리시간이 증가해 메모리의 사용이 정비례 한다(step : size = 1 : 1).

  > ex) search linked list, for문을 이용한 array 검색

- **O(n^2) (quadratic)**

  입력데이터의 크기에 따라 걸리는 시간은 제곱에 비례한다.

  > ex) 이중 for문

- **O(C^n) (exponential)**

  문제를 해결하기 위한 단계의 수는 주어진 상수값 C의 n제곱이다.

  > ex) 피보나치 수열, recursion



---



>[선형 자료구조](https://github.com/HibernationNo1/TIL/blob/master/Data_structure/%EC%84%A0%ED%98%95%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md)
>
>[비선형 자료구조](https://github.com/HibernationNo1/TIL/blob/master/Data_structure/%EB%B9%84%EC%84%A0%ED%98%95%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md)