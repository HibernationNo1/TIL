# UML

**UML정의 및 특징**

- OMG(Object Management Group) 표준 모델링 언어 (시스템을 위한 범용 시각화 모델링 언어)

- 소프트웨어 시스템 구축 과정에서 복잡한 업무를 이해하기 쉽도록 추상화하고, 구현하기 쉽도록 이해시켜준다.

- UML을 통해 다이어그램으로 소프트웨어 시스템이 구현하는 추상화된 업무를 문서화 할 수 있다.

- 다른 사람들과의 설계 논의 또는 소통을 위해 사용한다.
- 전체 시스템의 구조 및 클래스의 의존성을 파악할 수 있다.
- 유지보수를 위한 설예릐 back-end 문서이다.



---

## 1. UML 모델링 도구

### UML 모델링 도구 선택 기준

- 완전한 UML 2ver.을 제공해야 한다.

  > 6개의 구조, 7개의 행위 다이어그램

- 주요 모델링 기능을 제공해야 한다.

  > BPMN 기반 프로세스 모델링
  >
  > 요구 모델링
  >
  > 비즈니스 규칙 모델링
  >
  > 사용자 인터페이스 모델링
  >
  > ER기반 데이터 모델링

- 주요 지원 기능 제공해야 한다.

  > 문서화 기능
  >
  > 팀 작성 기능

- 이상적인 UML 모델링 도구 기능 (MDD기능)

  > 프로그래밍 언어 코드 생성: Java, C++ 등
  >
  > 기술 지원 코드 생성: 웹 서비스 등
  >
  > 구조 다이어그램에서 골격 코드 생성
  >
  > 행위 다이어그램에서 로직 코드 생성

### UML 모델링 도구 종류

#### 1. 오픈소스 UML 모델링 도구

무료로 사용할 수 있지만, 모든 다이어그램을 지원하는 것은 아니다.

**종류**

> - ArgoUML
> - Modelio

#### 2. 상용 UML 모델링 도구

**종류**

> - Rational Software Architect (대표적)
>
>   > 가격이 비싸고, 자바 기반에 특화되어 있다.
>
> - Rational Rhapsody
>
>   > 가격이 비싸고, realtime 임베디드에 많이 사용된다.
>   >
>   > 자바 기반에 특화되어 있다.
>
> - Enterprise Architect
>
>   > 비교적 저렴하고 window 기반으로 가볍다.
>   >
>   > 국내에서 많이 사용하고있다.
>
> - Visual Paradigm for UML
>
> - MagicDraw UML
>
>   > 정확안 UML 표기법 사용. 국내에선 잘 사용 안함
>
> - Altova UModel
>
>   > 역공학 UML
>
> - StarUML
>
>   > 등록되지 않은 상태로 전체 기능을 무료로 사용 가능

#### 3. 무료 UML 모델링 도구

**종류**

> - Visual Paradigm for UML Community Edition
>
>   > 상용 모델링 도구 Visual Paradigm for UML 에서 제한적인 다이어그램 사용 가능
>
> - Poseidon for UML Community Edition

---

## 2. UML 다이어그램

UML 다이어그램은 **구조 다이어그램**과 **행위 다이어그램**으로 나뉘어진다.

- ##### 구조 다이어그램 (6개)

  > 클래스, 컴포넌트, 객체, 배포, 컴포넌트 구조, 패키지

- ##### 행위 다이어그램 (7개)

  > 활동, 유스케이스, 상태, 인터랙션
  >
  > - 인터렉션 다이어그램의 종류
  >
  >   > 시퀀스, 커뮤니케이션, 인터렉션 오버뷰, 타이밍

  

### 1. 구조 다이어그램

#### 1. 클래스 다이어그램  ☆☆☆☆☆

시스템의 클래스와 이들 상호간의 관계를 표현한다.

애트리뷰트와 오퍼레이션을 하나의 단위로 캡슐화

##### 1. class

- 클래스: 클래스 이름

- 애트리뷰트: 멤버 변수

  > `-(또는+)애트리뷰터 : 데이터 타입`

- 오퍼레이션(): 메서드

  > `-(또는+)오퍼레이션(매개변수:매개변수타입) : 반환타입`

>  애트리뷰트와 오퍼레이션 앞에 붙는 부호는 가시성을 의미하며 외부에 노출시킬 것인지 여부를 결정한다.
>
> - private: -
> - protected: #
> - public: +
> - package: ~

##### 2. interface

- 인터페이스 클래스에 사용하는 사각형을 그대로 사용하고 <<interface>> 스테레오 타입을 가진 클래스로 표시한다.

  > `<<interface>> 인터페이스`

- 오퍼레이션만 포함하고 있다.

##### 3. 클래스 다이어그램 관계(Association)

모델 요소 사이의 의미적인 연결

- 구문

  > - 관계 이름: 원시 객체가 대상 객체에 대하여 수행하는 행위를 동사형으로 표현
  >
  > - 역할 이름: 클래스의 인스턴스 즉, 객체가 수행하는 나타내는 명사로 표현
  >
  > - 다수성: 특성한 시점에 관계에 포함될 수 있는 클래스의 객체 개수를 제한함
  >
  >   > 0 : 선택적을 의미
  >   >
  >   > 1 : 필수적을 의미
  >   >
  >   > **범위 표기법**
  >   >
  >   > - 0..1 : 0 또는 1
  >   > - 1 : 정확하게 1
  >   > - 0..* : 0 이상
  >   > - 1..7 : 1에서 7까지
  >   > - 1..3, 6, 8..10 : `,` 를 사용한 표기 가능
  >
  > - 방향성: 메시지가 화살의 방향으로만 전달될 수 있다는 것을 의미함
  >
  >   > 클래스 사이에 결합성을 이해할 수 있는 좋은 수단이 된다.
  >   >
  >   > - 양방향성(양쪽화살표) : 결합성이 높은  (수정하기 어려움)
  >   > - 단방향성(한쪽화살표) : 결합성이 낮음 (왠만하면 이렇게 설계)
  >   > - 무방향성(x표시) : 결합성이 없음
  >   > - 미정(표시없음) : 방향성을 아직 정하지 않았음

- 관계 종류

  - 연관 관계

  > 모델 요소 사이의 전체 부분(has a) 관계를 표현함
  >
  > - 집계 연관(Aggregation)
  >
  > > 부분 요소는 전체 요소 없이도 존재할 수 있음
  > >
  > > 전체 요소가 소멸될 때 부분 요소가 소멸되지 않을 수 있다. ex) 컴퓨터와 프린터  
  >
  > - 컴포지션 연관(Compose)
  >
  > > 전체 요소가 생성될 때 부분요소도 전체 요소의 일부분으로 함께 생성됨
  > >
  > > 전체 요소가 소멸되면 부분 요소도 소멸된다. ex) 마우스와 버튼
  > >
  > > C++언어에서 구현됨

  - 종속성 관계(Dependency)

  > 한 클래스가 다른 클래스를 사용하는 관계를 표현함 
  >
  > ex) A가 B에 종속된 클래스일 때
  >
  > - A로부터 B로 메시지가 전달 됨
  > - A가 B의 데이터의 일부가 됨
  > - B가 A를 오퍼레이션의 매개변수로 지정함

  - 일반화 관계(Generalization)

  > 한 클래스가 다른 클래스의 구조와 행위를 공유하는 관계 (C++에서 클래스의 상속)
  >
  > 서브 클래스가 수퍼 클래스를 상속하는 추상화 계층도를 정의함
  >
  > 상속성

  - 실현 관계(Realization)

  > 한 클래스가 다른 클래스 또는 **인터페이스**의 명세를 구현하는 관계를 표현함
  >
  > 객체지향의 다형성을 표현하는 수단이 됨

#### 2. 객체 다이어그램

실무에서 많이 사용하진 않지만, 클래스와 객체 사이의 관계를 이해하는데 도움을 준다.

클래스 다이어그램보다 더 구체적이면 일반저그올 클래스 다이어그램의 예를 제공하거나 테스트 케이스로서의 역할을 한다.

객체 박스(Object) : 객체의 인수는 set run state로 표현한다.

- 인스턴스

  > 클래스로부터 클래스 인스턴스가 생성됨

- 링크

  > 링크는 연관 관계의 인스턴스임



#### 3. 패키지 다이어그램

패키지와 패키지 사이의 관계를 표현한다.

분석/설계의 상위 레벨 개관을 보여주며 복잡한 다이어그램을 논리적으로 모듈화한다.

소스 코드를 구조화한다.

- 패키지 다이어그램의 이행성

  > A패키지와 B패키지 사이에 관계가 있음
  >
  > B패키지와 C패키지 사이에 관계까 있음
  >
  > 이 때 A패키지와 C패키지사이에는 내포 관계까 있음(A패키지가 C패키지 요소에 접근 가능)

- 패키지 다이어그램 관계

  - 포함 관계

    > 패키지 안에 다른 패키지와 모델 요소를 포함하는 관계
    >
    > 패키지 안에는 다른 모델 요소(클래스 등)도 포함할 수 있다.

  - 종속 관계

    > 패키지를 서로 연결하는 것은 종속성 관계다.
    >
    > 다른 패키지 안에 포함된 공개(public) 모델 요소를 어떤 방식으로든 사용한다는 것을 의미한다.
    >
    > Association(관계)에 스테레오타입을 사용해서 표현
    >
    > - <<import>> 종속성(Dependency)
    >
    >   > A패키지의 공개 요소가 B패키지의 공개 요소로 추가되는 것을 의미
    >   >
    >   > B패키지 안에 있는 요소는 한정자를 사용하지 않고도 A패키지 요소에 접근할 수 있음
    >   >
    >   > 이행성을 가짐
    >
    > - <<accsee>> 종속성(Dependency)
    >
    >   > A패키지의 공개 요소가 B패키지의 비공개 요소로 추가되는 것을 의미
    >   >
    >   > B패키지 안에 있는 요소는 한정자를 사용해야만 A패키지 요소에 접근할 수 있음
    >   >
    >   > 이행성을 갖지 않음



#### 4. 컴포넌트 다이어그램

논리적 또는 물리적인 시스템의 구조를 컴포넌트와 인터페이스 사이의 관계로 표현한 다이어그램

여러 인터페이스와 클래스를 묶어서 구조화

- 컴포넌트(component)

  > 캡슐화 되어있으며 재사용할 수 있고 대체할 수 있는 소프트웨어 모듈
  >
  > 제공된 인터페이스를 구현하여 외부에 서비스를 제공하고, 필수 인터페이스를 사용하여 내부 기능을 구현함
  >
  > - 제공된 인터페이스(provided interface)
  >
  >   > 컴포넌트가 구현하여 제공하는 인터페이스로 
  >
  > - 필수 인터페이스(required interface)
  >
  >   > 컴포넌트를 구현하는데 필수적으로 사용되는 인터페이스 (다른 컴포넌트의 제공된 인터페이스가 새로운 인터페이스를 구현하는데 필수 인터페이스로 작용하는 것임)
  >
  > - 포트(port)
  >
  >   > 제공된 인터페이스와 필수 인터페이스들을 하나의 그룹으로 묶어 구조화 해줌
  >   >
  >   > 컴포넌트간 상호작용 위치를 표시함
  >
  > 다이어그램을 표현할 때 포트와 인터페이스를 사용해서 상세하게 표현한다.



### 2. 행위 다이어그램

#### 1. 활동 다이어그램

시스템의 실행과 행위의 흐름을 표현한다.

작업 흐름이나 유스케이스의 이벤트 흐름을 표현하는데 적당하다.

- 활동 다이어그램 동작 구분

  - 활동

    > 하나 이상의 행위로 분해될 수 있는 동작

  - 행위

    > 실행할 수 있는 기능의 기본적인 단위
    >
    > 다이어그램에서 더 이상 작은 단위로 분할되지 않는 단일 스템

- 활동 다이어그램 요소

  - 행위 노드

    > 활동 안에서 구별된 원소적인 작업 단위를 표현한다
    >
    > - 행위 호출(action): 활동, 동작, 오퍼레이션을 호출함
    >
    >   > - 동작 호출(call behavior): 일반적인 행위의 동작을 호출하는 경우에 사용됨
    >   > - 활동 호출(call activity): 다른 활동 다이어그램으로 표현된 활동에 대한 연결을 호출할때 사용됨
    >   > - 오퍼레이션 호출(call operation): 특정한 클래스 또는 인터페이스, 서브시스템 등의 특정한 메서드나 오퍼레이션을 호출할때 사용됨
    >
    > - 신호 송신(send signal): 신호행위를 비동기적으로 송신함
    >
    >   > 신호 인스턴스를 생성하고 대상 객체에 전송하는 것을 표현한다.
    >
    > - 이벤트 수신(accept event): 이벤트 행위를 기다리고 수신함
    >
    >   > 독자적으로 사용할 수 있고 신호 송신과 함께 사용할 수도 있음
    >
    > - 시간 이벤트 수신(accept time event): 시간 이벤트 행위를 기다리고 수신함
    >
    >   > 시간에 반응하는 행위를 표현할때 사용됨
    >   >
    >   > 시간은 이벤트 발생 시간, 특정 시간 또는 기간이 될 수 있음

  - 제어 노드

    >하나의 노드에서 다른 노드로 제어가 흘러가는 것을 표현한다.
    >
    >보호조건(예외처리)을 가질 수 있음
    >
    >- 초기(initial): 활동을 시작하는 노드
    >
    >- 활동 최종(activity final): 모든 플로우 활동을 종료하는 노드
    >
    >- 플로우 최종(flow final): 해당 플로우를 종료하는 노드
    >
    >- 결정(dedision): 하나의 입력 플로우와 여러 출력 플로우를 갖는 노드
    >
    >  > 출력 플로우는 한 개만 실행이 됨(if문으로 이해하면 됨)
    >
    >- 병합(merge): 여러 입력 플로우를 병합하여 하나의 플로우로 출력하는 노드
    >
    >  > 하나의 플로우라도 입력이 되면 다음 플로우 실행
    >
    >- 분기 실행(fork): 하나의 입력 플로우를 동시에 여러 출력 플로우로 분기하여 실행시키는 노드
    >
    >  > 여러 플로우가 동시에 실행이 됨
    >
    >- 결합(join): 여러 입력 플로우를 동기화하여 하나의 플로우로 출력하는 노드 

  - 객체 노드

    > 활동 안에서 사용되는 객체를 표현한다.
    >
    > - 객체 흐름(object flow): 활동 안에서 데이터의 흐름을 표현함(객체 노드에만 사용할 수 있음)
    >
    > - 객체(object): 활동 다이어그램에 참여하는 일반적인 데이터를 표현
    >
    >   > 클래스 류의 인스턴스를 표현함
    >   >
    >   > 활동 안에서의 특정한 상태를 표현할 수 있음
    >
    > - 입력 핀(input pin): 행위와 활동에 데이터를 보내는 위치
    >
    > - 출력 핀(output pin): 행위와 활동에 데이터를 보내는 위치
    >
    > - 활동 매개변수(activity parameter): 활동으로 들어오고 나가는 데이터 매개변수
    >
    > - 중앙 버퍼(central buffer): 여러 소스 및 대상으로부터의 데이터 플로우 관리 노드
    >
    > - 데이터 스토어(data store): 데이터를 저장하고 추출하는 데이터 저장소

  - 파티션

    > 공통적인 특징을 갖는 행위를 식별하기 위한 활동 그룹으로 포함시키는 것. (행위노드 + 객체노드 + 제어노드)
    >
    > 일반적으로 비즈니스 모델에서 조직 단위에 해당하거나 (판매, 회원가입 등의)활동 프로세스 단위에 해당됨

- 활동 다이어그램 작성법

  1. 파티션 제작 > 초기노드 > 활동+제어+객체노드 > 활동 최종 노드



#### 2. 인터렉션 다이어그램

객체가 어떻게 상호작용하는가, 어떤 순서로 상호작용하는가를 표현한다.

**유형**

- 시퀀스 다이어그램, 커뮤니케이션 다이어그램

  > 유사한 정보를 다른 방식으로 표현한다. 대부분의 모델링 도구에서 상호 변환 기능을 제공한다.
  >
  > - 시퀀스 다이어그램: 상호작용의 시간 중심 관점(메시지의 명확한 순서를 표시함)
  >
  >   > 전반적인 흐름의 시각화, 복잡한 시나리오의 표현에 좋음
  >   >
  >   > 메시지 송-수신을 표현할때 사용
  >   >
  >   > - 라이프라인(lifeline): 특정 시간에 역할의 존재를 표현
  >   >
  >   > - 역할(role): 상호작용의 참여자
  >   >
  >   > - 활성화(activation): 행위에 참여함을 표현함
  >   >
  >   > - 메시지(message): 역할 사이의 상호작용을 표현함
  >   >
  >   >   - 동기 메시지(synchronous message): 동기적으로 메시지를 전송함
  >   >
  >   >     > 송신자는 수신자로부터 요청된 오퍼레이션의 실행을 완료한 후 반환을 받을때까지 기다린다.
  >   >
  >   >   - 비동기 메시지(asynchronous message): 비동기적으로 메시지를 전송함
  >   >
  >   >     > 송신자는 수신자로부터 반환을 기다리지 않고, 메시지를 보내고 다음 작업을 수행한다.
  >   >
  >   >   - 반환 메시지(return  message): 동기적 메시지의  호출을 반환함
  >   >
  >   >     > 이전 수신자가 송신자에게 완료 여부를 반환한다.
  >   >
  >   >   - 생성 메시지(create message): 송신자가 수신자의 인스턴스를 생성함
  >   >
  >   >   - 소명 메시지(destroy message): 송신자가 수신자의 인스턴스를 소멸함
  >   >
  >   > **결합 단편과 상호 작용 연산자는 필요할때 검색해서 공부할 것**
  >   >
  >   > 조건문, 반복문을 표현할때 사용
  > 
  > - 커뮤니케이션 다이어그램: 역할 사이의 메시징
  > 
  >   > 역할의 구조적 관점(상호작용과 함께 관계를 표시함)
  >   >
  >   > 역할 또는 파트에 대한 모든 효과의 표현에 좋음. 브레인스토밍 세션에 사용하기 쉬움
  >  >
  >   > 
  
- 인터랙션 오버뷰 다이어그램

- 타이밍 다이어그램



#### 3. 유스케이스 다이어그램

시스템의 행위를 모델링하며 시스템의 요구사항을 표현한다.

시스템의 상위 레벨 기능과 범위를 기술하고, 시스템이 기능을 어떻게 구현하는지는 기술하지 않는다.

- 주제(Subject)

  > 구축해야 할 시스템의 영역을 결정한다. (시스템 영역)

- 엑터(Actor)

  > 시스템 외부에서 시스템과 상호작용하는 사람이나 시스템(장치), 조직을 표현한다.

- 유스케이스(Use case)

  > 특정한 액터에게 가치가 있는 주목할 만한 결과를 산출하기 위해 시스템이 수행하는 행위의 연속을 의미함(도서 주문, 결제 확인 등등)
  >
  > 시스템의 행위가 시작에서 하나의 단위로 끝까지 완료되고 액터에게 가치있는 결과를 제공한다.

- 관계

  - 연관(Association)

    > 액터가 유스케이스를 사용하는 커뮤니케이션 관계

  - 포함(Include)

    > 하나의 유스케이스가 두 개 이상의 다른 유스케이스의 행위를 포함하는 관계일때 사용
    >
    > ex) '도서 주문'과 '결제 확인'은 '주문 완료'를 포함하고 있다.

  - 확장(Extend)

    > 하나의 유스케이스가 다른 유스케이스의 행위를 선택적으로 사용하는 관계
    >
    > 여러 유스케이스 안의 행위 중 동일한 부분을 식별하려 별도의 유스케이스로 표현할때 사용 

  - 일반화(Generalize)

    > 여러 유스케이스의 부모 관계인 유스케이스를 표현할 때 사용한다.
    >
    > 자식 유스케이스는 부모 유스케이스의 기능을 상속받으며 새로운 기능을 추가하거나 상속된 기능을 변경한다.
    >
    > 액터끼리도 적용할 수 있다.
    >
    > ex) 신용카드 결제, 마일리지 결제, 무통장 입금은 '대금결제' 유스케이스의 자식 유스케이스로 대금결제 유스케이스는 세 자식 유스케이스를 **일반화** 한 것
    >
    > ex) 고객은 비회원과 회원을 일반화한 액터임

---

## 3. UML을 활용한 프로그램 디자인 순서

#### 단계별 순서

1. 요구사항 분석 **[필수]** 
2. 요구사항에 대한 기능 구조화(유스케이스 다이어그램) **[필수]** 
3. 시스템 구조를 표현(컴포넌트 다이어그램) **[필수]**
4. 코드 구성을 구조화(클래스 다이어그램)  **[필수]**
5. 시스템 행위의 구조화(활동 다이어그램)
6. 각 행위의 동작(신호 송-수신 또는 반복문, 조건문, 역할)을 구조화 (활동 다이어그램)





 